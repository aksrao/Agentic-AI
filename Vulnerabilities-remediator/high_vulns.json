[
  {
    "title": "bind: bind: Denial of Service via corrupt or malicious record",
    "cve": "CVE-2025-13878",
    "package": "bind9-host",
    "severity": "HIGH",
    "installed_version": "1:9.20.11-4",
    "fixed_version": "1:9.20.18-1~deb13u1",
    "description": "Malformed BRID/HHIT records can cause `named` to terminate unexpectedly.\nThis issue affects BIND 9 versions 9.18.40 through 9.18.43, 9.20.13 through 9.20.17, 9.21.12 through 9.21.16, 9.18.40-S1 through 9.18.43-S1, and 9.20.13-S1 through 9.20.17-S1.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "bind: Cache poisoning attacks with unsolicited RRs",
    "cve": "CVE-2025-40778",
    "package": "bind9-host",
    "severity": "HIGH",
    "installed_version": "1:9.20.11-4",
    "fixed_version": "1:9.20.15-1~deb13u1",
    "description": "Under certain circumstances, BIND is too lenient when accepting records from answers, allowing an attacker to inject forged data into the cache.\nThis issue affects BIND 9 versions 9.11.0 through 9.16.50, 9.18.0 through 9.18.39, 9.20.0 through 9.20.13, 9.21.0 through 9.21.12, 9.11.3-S1 through 9.16.50-S1, 9.18.11-S1 through 9.18.39-S1, and 9.20.9-S1 through 9.20.13-S1.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "bind: Cache poisoning due to weak PRNG",
    "cve": "CVE-2025-40780",
    "package": "bind9-host",
    "severity": "HIGH",
    "installed_version": "1:9.20.11-4",
    "fixed_version": "1:9.20.15-1~deb13u1",
    "description": "In specific circumstances, due to a weakness in the Pseudo Random Number Generator (PRNG) that is used, it is possible for an attacker to predict the source port and query ID that BIND will use.\nThis issue affects BIND 9 versions 9.16.0 through 9.16.50, 9.18.0 through 9.18.39, 9.20.0 through 9.20.13, 9.21.0 through 9.21.12, 9.16.8-S1 through 9.16.50-S1, 9.18.11-S1 through 9.18.39-S1, and 9.20.9-S1 through 9.20.13-S1.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "bind: Resource exhaustion via malformed DNSKEY handling",
    "cve": "CVE-2025-8677",
    "package": "bind9-host",
    "severity": "HIGH",
    "installed_version": "1:9.20.11-4",
    "fixed_version": "1:9.20.15-1~deb13u1",
    "description": "Querying for records within a specially crafted zone containing certain malformed DNSKEY records can lead to CPU exhaustion.\nThis issue affects BIND 9 versions 9.18.0 through 9.18.39, 9.20.0 through 9.20.13, 9.21.0 through 9.21.12, 9.18.11-S1 through 9.18.39-S1, and 9.20.9-S1 through 9.20.13-S1.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "bind: bind: Denial of Service via corrupt or malicious record",
    "cve": "CVE-2025-13878",
    "package": "bind9-libs",
    "severity": "HIGH",
    "installed_version": "1:9.20.11-4",
    "fixed_version": "1:9.20.18-1~deb13u1",
    "description": "Malformed BRID/HHIT records can cause `named` to terminate unexpectedly.\nThis issue affects BIND 9 versions 9.18.40 through 9.18.43, 9.20.13 through 9.20.17, 9.21.12 through 9.21.16, 9.18.40-S1 through 9.18.43-S1, and 9.20.13-S1 through 9.20.17-S1.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "bind: Cache poisoning attacks with unsolicited RRs",
    "cve": "CVE-2025-40778",
    "package": "bind9-libs",
    "severity": "HIGH",
    "installed_version": "1:9.20.11-4",
    "fixed_version": "1:9.20.15-1~deb13u1",
    "description": "Under certain circumstances, BIND is too lenient when accepting records from answers, allowing an attacker to inject forged data into the cache.\nThis issue affects BIND 9 versions 9.11.0 through 9.16.50, 9.18.0 through 9.18.39, 9.20.0 through 9.20.13, 9.21.0 through 9.21.12, 9.11.3-S1 through 9.16.50-S1, 9.18.11-S1 through 9.18.39-S1, and 9.20.9-S1 through 9.20.13-S1.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "bind: Cache poisoning due to weak PRNG",
    "cve": "CVE-2025-40780",
    "package": "bind9-libs",
    "severity": "HIGH",
    "installed_version": "1:9.20.11-4",
    "fixed_version": "1:9.20.15-1~deb13u1",
    "description": "In specific circumstances, due to a weakness in the Pseudo Random Number Generator (PRNG) that is used, it is possible for an attacker to predict the source port and query ID that BIND will use.\nThis issue affects BIND 9 versions 9.16.0 through 9.16.50, 9.18.0 through 9.18.39, 9.20.0 through 9.20.13, 9.21.0 through 9.21.12, 9.16.8-S1 through 9.16.50-S1, 9.18.11-S1 through 9.18.39-S1, and 9.20.9-S1 through 9.20.13-S1.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "bind: Resource exhaustion via malformed DNSKEY handling",
    "cve": "CVE-2025-8677",
    "package": "bind9-libs",
    "severity": "HIGH",
    "installed_version": "1:9.20.11-4",
    "fixed_version": "1:9.20.15-1~deb13u1",
    "description": "Querying for records within a specially crafted zone containing certain malformed DNSKEY records can lead to CPU exhaustion.\nThis issue affects BIND 9 versions 9.18.0 through 9.18.39, 9.20.0 through 9.20.13, 9.21.0 through 9.21.12, 9.18.11-S1 through 9.18.39-S1, and 9.20.9-S1 through 9.20.13-S1.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "GnuPG: GnuPG: Stack-based buffer overflow in tpm2daemon allows arbitrary code execution",
    "cve": "CVE-2026-24882",
    "package": "dirmngr",
    "severity": "HIGH",
    "installed_version": "2.4.7-21+deb13u1+b1",
    "fixed_version": null,
    "description": "In GnuPG before 2.5.17, a stack-based buffer overflow exists in tpm2daemon during handling of the PKDECRYPT command for TPM-backed RSA and ECC keys.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "GnuPG: GnuPG: Stack-based buffer overflow in tpm2daemon allows arbitrary code execution",
    "cve": "CVE-2026-24882",
    "package": "gnupg",
    "severity": "HIGH",
    "installed_version": "2.4.7-21+deb13u1",
    "fixed_version": null,
    "description": "In GnuPG before 2.5.17, a stack-based buffer overflow exists in tpm2daemon during handling of the PKDECRYPT command for TPM-backed RSA and ECC keys.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "GnuPG: GnuPG: Stack-based buffer overflow in tpm2daemon allows arbitrary code execution",
    "cve": "CVE-2026-24882",
    "package": "gnupg-l10n",
    "severity": "HIGH",
    "installed_version": "2.4.7-21+deb13u1",
    "fixed_version": null,
    "description": "In GnuPG before 2.5.17, a stack-based buffer overflow exists in tpm2daemon during handling of the PKDECRYPT command for TPM-backed RSA and ECC keys.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "GnuPG: GnuPG: Stack-based buffer overflow in tpm2daemon allows arbitrary code execution",
    "cve": "CVE-2026-24882",
    "package": "gnupg-utils",
    "severity": "HIGH",
    "installed_version": "2.4.7-21+deb13u1+b1",
    "fixed_version": null,
    "description": "In GnuPG before 2.5.17, a stack-based buffer overflow exists in tpm2daemon during handling of the PKDECRYPT command for TPM-backed RSA and ECC keys.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "GnuPG: GnuPG: Stack-based buffer overflow in tpm2daemon allows arbitrary code execution",
    "cve": "CVE-2026-24882",
    "package": "gpg",
    "severity": "HIGH",
    "installed_version": "2.4.7-21+deb13u1+b1",
    "fixed_version": null,
    "description": "In GnuPG before 2.5.17, a stack-based buffer overflow exists in tpm2daemon during handling of the PKDECRYPT command for TPM-backed RSA and ECC keys.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "GnuPG: GnuPG: Stack-based buffer overflow in tpm2daemon allows arbitrary code execution",
    "cve": "CVE-2026-24882",
    "package": "gpg-agent",
    "severity": "HIGH",
    "installed_version": "2.4.7-21+deb13u1+b1",
    "fixed_version": null,
    "description": "In GnuPG before 2.5.17, a stack-based buffer overflow exists in tpm2daemon during handling of the PKDECRYPT command for TPM-backed RSA and ECC keys.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "GnuPG: GnuPG: Stack-based buffer overflow in tpm2daemon allows arbitrary code execution",
    "cve": "CVE-2026-24882",
    "package": "gpg-wks-client",
    "severity": "HIGH",
    "installed_version": "2.4.7-21+deb13u1+b1",
    "fixed_version": null,
    "description": "In GnuPG before 2.5.17, a stack-based buffer overflow exists in tpm2daemon during handling of the PKDECRYPT command for TPM-backed RSA and ECC keys.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "GnuPG: GnuPG: Stack-based buffer overflow in tpm2daemon allows arbitrary code execution",
    "cve": "CVE-2026-24882",
    "package": "gpgconf",
    "severity": "HIGH",
    "installed_version": "2.4.7-21+deb13u1+b1",
    "fixed_version": null,
    "description": "In GnuPG before 2.5.17, a stack-based buffer overflow exists in tpm2daemon during handling of the PKDECRYPT command for TPM-backed RSA and ECC keys.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "GnuPG: GnuPG: Stack-based buffer overflow in tpm2daemon allows arbitrary code execution",
    "cve": "CVE-2026-24882",
    "package": "gpgsm",
    "severity": "HIGH",
    "installed_version": "2.4.7-21+deb13u1+b1",
    "fixed_version": null,
    "description": "In GnuPG before 2.5.17, a stack-based buffer overflow exists in tpm2daemon during handling of the PKDECRYPT command for TPM-backed RSA and ECC keys.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "GnuPG: GnuPG: Stack-based buffer overflow in tpm2daemon allows arbitrary code execution",
    "cve": "CVE-2026-24882",
    "package": "gpgv",
    "severity": "HIGH",
    "installed_version": "2.4.7-21+deb13u1+b1",
    "fixed_version": null,
    "description": "In GnuPG before 2.5.17, a stack-based buffer overflow exists in tpm2daemon during handling of the PKDECRYPT command for TPM-backed RSA and ECC keys.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "grub2: Missing unregister call for gettext command may lead to use-after-free",
    "cve": "CVE-2025-61662",
    "package": "grub-common",
    "severity": "HIGH",
    "installed_version": "2.12-9",
    "fixed_version": null,
    "description": "A Use-After-Free vulnerability has been discovered in GRUB's gettext module. This flaw stems from a programming error where the gettext command remains registered in memory after its module is unloaded. An attacker can exploit this condition by invoking the orphaned command, causing the application to access a memory location that is no longer valid. An attacker could exploit this vulnerability to cause grub to crash, leading to a Denial of Service. Possible data integrity or confidentiality compromise is not discarded.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "grub2: Missing unregister call for gettext command may lead to use-after-free",
    "cve": "CVE-2025-61662",
    "package": "grub-efi-amd64-bin",
    "severity": "HIGH",
    "installed_version": "2.12-9",
    "fixed_version": null,
    "description": "A Use-After-Free vulnerability has been discovered in GRUB's gettext module. This flaw stems from a programming error where the gettext command remains registered in memory after its module is unloaded. An attacker can exploit this condition by invoking the orphaned command, causing the application to access a memory location that is no longer valid. An attacker could exploit this vulnerability to cause grub to crash, leading to a Denial of Service. Possible data integrity or confidentiality compromise is not discarded.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "grub2: Missing unregister call for gettext command may lead to use-after-free",
    "cve": "CVE-2025-61662",
    "package": "grub-efi-amd64-unsigned",
    "severity": "HIGH",
    "installed_version": "2.12-9",
    "fixed_version": null,
    "description": "A Use-After-Free vulnerability has been discovered in GRUB's gettext module. This flaw stems from a programming error where the gettext command remains registered in memory after its module is unloaded. An attacker can exploit this condition by invoking the orphaned command, causing the application to access a memory location that is no longer valid. An attacker could exploit this vulnerability to cause grub to crash, leading to a Denial of Service. Possible data integrity or confidentiality compromise is not discarded.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "grub2: Missing unregister call for gettext command may lead to use-after-free",
    "cve": "CVE-2025-61662",
    "package": "grub-pc-bin",
    "severity": "HIGH",
    "installed_version": "2.12-9",
    "fixed_version": null,
    "description": "A Use-After-Free vulnerability has been discovered in GRUB's gettext module. This flaw stems from a programming error where the gettext command remains registered in memory after its module is unloaded. An attacker can exploit this condition by invoking the orphaned command, causing the application to access a memory location that is no longer valid. An attacker could exploit this vulnerability to cause grub to crash, leading to a Denial of Service. Possible data integrity or confidentiality compromise is not discarded.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "grub2: Missing unregister call for gettext command may lead to use-after-free",
    "cve": "CVE-2025-61662",
    "package": "grub2-common",
    "severity": "HIGH",
    "installed_version": "2.12-9",
    "fixed_version": null,
    "description": "A Use-After-Free vulnerability has been discovered in GRUB's gettext module. This flaw stems from a programming error where the gettext command remains registered in memory after its module is unloaded. An attacker can exploit this condition by invoking the orphaned command, causing the application to access a memory location that is no longer valid. An attacker could exploit this vulnerability to cause grub to crash, leading to a Denial of Service. Possible data integrity or confidentiality compromise is not discarded.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "glibc: Integer overflow in memalign leads to heap corruption",
    "cve": "CVE-2026-0861",
    "package": "libc-bin",
    "severity": "HIGH",
    "installed_version": "2.41-12+deb13u1",
    "fixed_version": null,
    "description": "Passing too large an alignment to the memalign suite of functions (memalign, posix_memalign, aligned_alloc) in the GNU C Library version 2.30 to 2.42 may result in an integer overflow, which could consequently result in a heap corruption.\n\nNote that the attacker must have control over both, the size as well as the alignment arguments of the memalign function to be able to exploit this.  The size parameter must be close enough to PTRDIFF_MAX so as to overflow size_t along with the large alignment argument.  This limits the malicious inputs for the alignment for memalign to the range [1<<62+ 1, 1<<63] and exactly 1<<63 for posix_memalign and aligned_alloc.\n\nTypically the alignment argument passed to such functions is a known constrained quantity (e.g. page size, block size, struct sizes) and is not attacker controlled, because of which this may not be easily exploitable in practice.  An application bug could potentially result in the input alignment being too large, e.g. due to a different buffer overflow or integer overflow in the application or its dependent libraries, but that is again an uncommon usage pattern given typical sources of alignments.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "glibc: Integer overflow in memalign leads to heap corruption",
    "cve": "CVE-2026-0861",
    "package": "libc-dev-bin",
    "severity": "HIGH",
    "installed_version": "2.41-12+deb13u1",
    "fixed_version": null,
    "description": "Passing too large an alignment to the memalign suite of functions (memalign, posix_memalign, aligned_alloc) in the GNU C Library version 2.30 to 2.42 may result in an integer overflow, which could consequently result in a heap corruption.\n\nNote that the attacker must have control over both, the size as well as the alignment arguments of the memalign function to be able to exploit this.  The size parameter must be close enough to PTRDIFF_MAX so as to overflow size_t along with the large alignment argument.  This limits the malicious inputs for the alignment for memalign to the range [1<<62+ 1, 1<<63] and exactly 1<<63 for posix_memalign and aligned_alloc.\n\nTypically the alignment argument passed to such functions is a known constrained quantity (e.g. page size, block size, struct sizes) and is not attacker controlled, because of which this may not be easily exploitable in practice.  An application bug could potentially result in the input alignment being too large, e.g. due to a different buffer overflow or integer overflow in the application or its dependent libraries, but that is again an uncommon usage pattern given typical sources of alignments.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "glibc: Integer overflow in memalign leads to heap corruption",
    "cve": "CVE-2026-0861",
    "package": "libc-l10n",
    "severity": "HIGH",
    "installed_version": "2.41-12+deb13u1",
    "fixed_version": null,
    "description": "Passing too large an alignment to the memalign suite of functions (memalign, posix_memalign, aligned_alloc) in the GNU C Library version 2.30 to 2.42 may result in an integer overflow, which could consequently result in a heap corruption.\n\nNote that the attacker must have control over both, the size as well as the alignment arguments of the memalign function to be able to exploit this.  The size parameter must be close enough to PTRDIFF_MAX so as to overflow size_t along with the large alignment argument.  This limits the malicious inputs for the alignment for memalign to the range [1<<62+ 1, 1<<63] and exactly 1<<63 for posix_memalign and aligned_alloc.\n\nTypically the alignment argument passed to such functions is a known constrained quantity (e.g. page size, block size, struct sizes) and is not attacker controlled, because of which this may not be easily exploitable in practice.  An application bug could potentially result in the input alignment being too large, e.g. due to a different buffer overflow or integer overflow in the application or its dependent libraries, but that is again an uncommon usage pattern given typical sources of alignments.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "glibc: Integer overflow in memalign leads to heap corruption",
    "cve": "CVE-2026-0861",
    "package": "libc6",
    "severity": "HIGH",
    "installed_version": "2.41-12+deb13u1",
    "fixed_version": null,
    "description": "Passing too large an alignment to the memalign suite of functions (memalign, posix_memalign, aligned_alloc) in the GNU C Library version 2.30 to 2.42 may result in an integer overflow, which could consequently result in a heap corruption.\n\nNote that the attacker must have control over both, the size as well as the alignment arguments of the memalign function to be able to exploit this.  The size parameter must be close enough to PTRDIFF_MAX so as to overflow size_t along with the large alignment argument.  This limits the malicious inputs for the alignment for memalign to the range [1<<62+ 1, 1<<63] and exactly 1<<63 for posix_memalign and aligned_alloc.\n\nTypically the alignment argument passed to such functions is a known constrained quantity (e.g. page size, block size, struct sizes) and is not attacker controlled, because of which this may not be easily exploitable in practice.  An application bug could potentially result in the input alignment being too large, e.g. due to a different buffer overflow or integer overflow in the application or its dependent libraries, but that is again an uncommon usage pattern given typical sources of alignments.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "glibc: Integer overflow in memalign leads to heap corruption",
    "cve": "CVE-2026-0861",
    "package": "libc6-dev",
    "severity": "HIGH",
    "installed_version": "2.41-12+deb13u1",
    "fixed_version": null,
    "description": "Passing too large an alignment to the memalign suite of functions (memalign, posix_memalign, aligned_alloc) in the GNU C Library version 2.30 to 2.42 may result in an integer overflow, which could consequently result in a heap corruption.\n\nNote that the attacker must have control over both, the size as well as the alignment arguments of the memalign function to be able to exploit this.  The size parameter must be close enough to PTRDIFF_MAX so as to overflow size_t along with the large alignment argument.  This limits the malicious inputs for the alignment for memalign to the range [1<<62+ 1, 1<<63] and exactly 1<<63 for posix_memalign and aligned_alloc.\n\nTypically the alignment argument passed to such functions is a known constrained quantity (e.g. page size, block size, struct sizes) and is not attacker controlled, because of which this may not be easily exploitable in practice.  An application bug could potentially result in the input alignment being too large, e.g. due to a different buffer overflow or integer overflow in the application or its dependent libraries, but that is again an uncommon usage pattern given typical sources of alignments.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "glib: Integer overflow in in g_escape_uri_string()",
    "cve": "CVE-2025-13601",
    "package": "libglib2.0-0t64",
    "severity": "HIGH",
    "installed_version": "2.84.4-3~deb13u1",
    "fixed_version": "2.84.4-3~deb13u2",
    "description": "A heap-based buffer overflow problem was found in glib through an incorrect calculation of buffer size in the g_escape_uri_string() function. If the string to escape contains a very large number of unacceptable characters (which would need escaping), the calculation of the length of the escaped string could overflow, leading to a potential write off the end of the newly allocated string.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs uninitialized memory exposure",
    "cve": "CVE-2025-55131",
    "package": "libnode115",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "A flaw in Node.js's buffer allocation logic can expose uninitialized memory when allocations are interrupted, when using the `vm` module with the timeout option. Under specific timing conditions, buffers allocated with `Buffer.alloc` and other `TypedArray` instances like `Uint8Array` may contain leftover data from previous operations, allowing in-process secrets like tokens or passwords to leak or causing data corruption. While exploitation typically requires precise timing or in-process code execution, it can become remotely exploitable when untrusted input influences workload and timeouts, leading to potential confidentiality and integrity impact.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs denial of service",
    "cve": "CVE-2025-59465",
    "package": "libnode115",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "A malformed `HTTP/2 HEADERS` frame with oversized, invalid `HPACK` data can cause Node.js to crash by triggering an unhandled `TLSSocket` error `ECONNRESET`. Instead of safely closing the connection, the process crashes, enabling a remote denial of service. This primarily affects applications that do not attach explicit error handlers to secure sockets, for example:\n```\nserver.on('secureConnection', socket => {\n  socket.on('error', err => {\n    console.log(err)\n  })\n})\n```",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs denial of service",
    "cve": "CVE-2025-59466",
    "package": "libnode115",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "We have identified a bug in Node.js error handling where \"Maximum call stack size exceeded\" errors become uncatchable when `async_hooks.createHook()` is enabled. Instead of reaching `process.on('uncaughtException')`, the process terminates, making the crash unrecoverable. Applications that rely on `AsyncLocalStorage` (v22, v20) or `async_hooks.createHook()` (v24, v22, v20) become vulnerable to denial-of-service crashes triggered by deep recursion under specific conditions.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs denial of service",
    "cve": "CVE-2026-21637",
    "package": "libnode115",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "A flaw in Node.js TLS error handling allows remote attackers to crash or exhaust resources of a TLS server when `pskCallback` or `ALPNCallback` are in use. Synchronous exceptions thrown during these callbacks bypass standard TLS error handling paths (tlsClientError and error), causing either immediate process termination or silent file descriptor leaks that eventually lead to denial of service. Because these callbacks process attacker-controlled input during the TLS handshake, a remote client can repeatedly trigger the issue. This vulnerability affects TLS servers using PSK or ALPN callbacks across Node.js versions where these callbacks throw without being safely wrapped.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "libpng: LIBPNG buffer overflow",
    "cve": "CVE-2025-64720",
    "package": "libpng16-16t64",
    "severity": "HIGH",
    "installed_version": "1.6.48-1",
    "fixed_version": "1.6.48-1+deb13u1",
    "description": "LIBPNG is a reference library for use in applications that read, create, and manipulate PNG (Portable Network Graphics) raster image files. From version 1.6.0 to before 1.6.51, an out-of-bounds read vulnerability exists in png_image_read_composite when processing palette images with PNG_FLAG_OPTIMIZE_ALPHA enabled. The palette compositing code in png_init_read_transformations incorrectly applies background compositing during premultiplication, violating the invariant component \u2264 alpha \u00d7 257 required by the simplified PNG API. This issue has been patched in version 1.6.51.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "libpng: LIBPNG heap buffer overflow",
    "cve": "CVE-2025-65018",
    "package": "libpng16-16t64",
    "severity": "HIGH",
    "installed_version": "1.6.48-1",
    "fixed_version": "1.6.48-1+deb13u1",
    "description": "LIBPNG is a reference library for use in applications that read, create, and manipulate PNG (Portable Network Graphics) raster image files. From version 1.6.0 to before 1.6.51, there is a heap buffer overflow vulnerability in the libpng simplified API function png_image_finish_read when processing 16-bit interlaced PNGs with 8-bit output format. Attacker-crafted interlaced PNG files cause heap writes beyond allocated buffer bounds. This issue has been patched in version 1.6.51.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "libpng: LIBPNG out-of-bounds read in png_image_read_composite",
    "cve": "CVE-2025-66293",
    "package": "libpng16-16t64",
    "severity": "HIGH",
    "installed_version": "1.6.48-1",
    "fixed_version": "1.6.48-1+deb13u1",
    "description": "LIBPNG is a reference library for use in applications that read, create, and manipulate PNG (Portable Network Graphics) raster image files. Prior to 1.6.52, an out-of-bounds read vulnerability in libpng's simplified API allows reading up to 1012 bytes beyond the png_sRGB_base[512] array when processing valid palette PNG images with partial transparency and gamma correction. The PNG files that trigger this vulnerability are valid per the PNG specification; the bug is in libpng's internal state management. Upgrade to libpng 1.6.52 or later.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "libpng: libpng: Denial of service and information disclosure via heap buffer over-read in png_image_finish_read",
    "cve": "CVE-2026-22695",
    "package": "libpng16-16t64",
    "severity": "HIGH",
    "installed_version": "1.6.48-1",
    "fixed_version": null,
    "description": "LIBPNG is a reference library for use in applications that read, create, and manipulate PNG (Portable Network Graphics) raster image files. From 1.6.51 to 1.6.53, there is a heap buffer over-read in the libpng simplified API function png_image_finish_read when processing interlaced 16-bit PNGs with 8-bit output format and non-minimal row stride. This is a regression introduced by the fix for CVE-2025-65018. This vulnerability is fixed in 1.6.54.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "libpng: libpng: Information disclosure and denial of service via integer truncation in simplified write API",
    "cve": "CVE-2026-22801",
    "package": "libpng16-16t64",
    "severity": "HIGH",
    "installed_version": "1.6.48-1",
    "fixed_version": null,
    "description": "LIBPNG is a reference library for use in applications that read, create, and manipulate PNG (Portable Network Graphics) raster image files. From 1.6.26 to 1.6.53, there is an integer truncation in the libpng simplified write API functions png_write_image_16bit and png_write_image_8bit causes heap buffer over-read when the caller provides a negative row stride (for bottom-up image layouts) or a stride exceeding 65535 bytes. The bug was introduced in libpng 1.6.26 (October 2016) by casts added to silence compiler warnings on 16-bit systems. This vulnerability is fixed in 1.6.54.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: IMAP command injection in user-controlled commands",
    "cve": "CVE-2025-15366",
    "package": "libpython3.13",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The imaplib module, when passed a user-controlled command, can have additional commands injected using newlines. Mitigation rejects commands containing control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: POP3 command injection in user-controlled commands",
    "cve": "CVE-2025-15367",
    "package": "libpython3.13",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The poplib module, when passed a user-controlled command, can have\nadditional commands injected using newlines. Mitigation rejects commands\ncontaining control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: Cpython infinite loop when parsing a tarfile",
    "cve": "CVE-2025-8194",
    "package": "libpython3.13",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "There is a defect in the CPython \u201ctarfile\u201d module affecting the \u201cTarFile\u201d extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives. \n\nThis vulnerability can be mitigated by including the following patch after importing the \u201ctarfile\u201d module:\u00a0 https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: email header injection due to unquoted newlines",
    "cve": "CVE-2026-1299",
    "package": "libpython3.13",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The \nemail module, specifically the \"BytesGenerator\" class, didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized. This is only applicable if using \"LiteralHeader\" writing headers that don't respect email folding rules, the new behavior will reject the incorrectly folded headers in \"BytesGenerator\".",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: IMAP command injection in user-controlled commands",
    "cve": "CVE-2025-15366",
    "package": "libpython3.13-dev",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The imaplib module, when passed a user-controlled command, can have additional commands injected using newlines. Mitigation rejects commands containing control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: POP3 command injection in user-controlled commands",
    "cve": "CVE-2025-15367",
    "package": "libpython3.13-dev",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The poplib module, when passed a user-controlled command, can have\nadditional commands injected using newlines. Mitigation rejects commands\ncontaining control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: Cpython infinite loop when parsing a tarfile",
    "cve": "CVE-2025-8194",
    "package": "libpython3.13-dev",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "There is a defect in the CPython \u201ctarfile\u201d module affecting the \u201cTarFile\u201d extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives. \n\nThis vulnerability can be mitigated by including the following patch after importing the \u201ctarfile\u201d module:\u00a0 https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: email header injection due to unquoted newlines",
    "cve": "CVE-2026-1299",
    "package": "libpython3.13-dev",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The \nemail module, specifically the \"BytesGenerator\" class, didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized. This is only applicable if using \"LiteralHeader\" writing headers that don't respect email folding rules, the new behavior will reject the incorrectly folded headers in \"BytesGenerator\".",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: IMAP command injection in user-controlled commands",
    "cve": "CVE-2025-15366",
    "package": "libpython3.13-minimal",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The imaplib module, when passed a user-controlled command, can have additional commands injected using newlines. Mitigation rejects commands containing control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: POP3 command injection in user-controlled commands",
    "cve": "CVE-2025-15367",
    "package": "libpython3.13-minimal",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The poplib module, when passed a user-controlled command, can have\nadditional commands injected using newlines. Mitigation rejects commands\ncontaining control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: Cpython infinite loop when parsing a tarfile",
    "cve": "CVE-2025-8194",
    "package": "libpython3.13-minimal",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "There is a defect in the CPython \u201ctarfile\u201d module affecting the \u201cTarFile\u201d extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives. \n\nThis vulnerability can be mitigated by including the following patch after importing the \u201ctarfile\u201d module:\u00a0 https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: email header injection due to unquoted newlines",
    "cve": "CVE-2026-1299",
    "package": "libpython3.13-minimal",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The \nemail module, specifically the \"BytesGenerator\" class, didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized. This is only applicable if using \"LiteralHeader\" writing headers that don't respect email folding rules, the new behavior will reject the incorrectly folded headers in \"BytesGenerator\".",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: IMAP command injection in user-controlled commands",
    "cve": "CVE-2025-15366",
    "package": "libpython3.13-stdlib",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The imaplib module, when passed a user-controlled command, can have additional commands injected using newlines. Mitigation rejects commands containing control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: POP3 command injection in user-controlled commands",
    "cve": "CVE-2025-15367",
    "package": "libpython3.13-stdlib",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The poplib module, when passed a user-controlled command, can have\nadditional commands injected using newlines. Mitigation rejects commands\ncontaining control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: Cpython infinite loop when parsing a tarfile",
    "cve": "CVE-2025-8194",
    "package": "libpython3.13-stdlib",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "There is a defect in the CPython \u201ctarfile\u201d module affecting the \u201cTarFile\u201d extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives. \n\nThis vulnerability can be mitigated by including the following patch after importing the \u201ctarfile\u201d module:\u00a0 https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: email header injection due to unquoted newlines",
    "cve": "CVE-2026-1299",
    "package": "libpython3.13-stdlib",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The \nemail module, specifically the \"BytesGenerator\" class, didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized. This is only applicable if using \"LiteralHeader\" writing headers that don't respect email folding rules, the new behavior will reject the incorrectly folded headers in \"BytesGenerator\".",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "openssl: OpenSSL: Arbitrary code execution due to out-of-bounds write in PKCS#12 processing",
    "cve": "CVE-2025-69419",
    "package": "libssl3t64",
    "severity": "HIGH",
    "installed_version": "3.5.1-1+deb13u1",
    "fixed_version": "3.5.4-1~deb13u2",
    "description": "Issue summary: Calling PKCS12_get_friendlyname() function on a maliciously\ncrafted PKCS#12 file with a BMPString (UTF-16BE) friendly name containing\nnon-ASCII BMP code point can trigger a one byte write before the allocated\nbuffer.\n\nImpact summary: The out-of-bounds write can cause a memory corruption\nwhich can have various consequences including a Denial of Service.\n\nThe OPENSSL_uni2utf8() function performs a two-pass conversion of a PKCS#12\nBMPString (UTF-16BE) to UTF-8. In the second pass, when emitting UTF-8 bytes,\nthe helper function bmp_to_utf8() incorrectly forwards the remaining UTF-16\nsource byte count as the destination buffer capacity to UTF8_putc(). For BMP\ncode points above U+07FF, UTF-8 requires three bytes, but the forwarded\ncapacity can be just two bytes. UTF8_putc() then returns -1, and this negative\nvalue is added to the output length without validation, causing the\nlength to become negative. The subsequent trailing NUL byte is then written\nat a negative offset, causing write outside of heap allocated buffer.\n\nThe vulnerability is reachable via the public PKCS12_get_friendlyname() API\nwhen parsing attacker-controlled PKCS#12 files. While PKCS12_parse() uses a\ndifferent code path that avoids this issue, PKCS12_get_friendlyname() directly\ninvokes the vulnerable function. Exploitation requires an attacker to provide\na malicious PKCS#12 file to be parsed by the application and the attacker\ncan just trigger a one zero byte write before the allocated buffer.\nFor that reason the issue was assessed as Low severity according to our\nSecurity Policy.\n\nThe FIPS modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,\nas the PKCS#12 implementation is outside the OpenSSL FIPS module boundary.\n\nOpenSSL 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.\n\nOpenSSL 1.0.2 is not affected by this issue.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "openssl: OpenSSL: Denial of Service via malformed PKCS#12 file processing",
    "cve": "CVE-2025-69421",
    "package": "libssl3t64",
    "severity": "HIGH",
    "installed_version": "3.5.1-1+deb13u1",
    "fixed_version": "3.5.4-1~deb13u2",
    "description": "Issue summary: Processing a malformed PKCS#12 file can trigger a NULL pointer\ndereference in the PKCS12_item_decrypt_d2i_ex() function.\n\nImpact summary: A NULL pointer dereference can trigger a crash which leads to\nDenial of Service for an application processing PKCS#12 files.\n\nThe PKCS12_item_decrypt_d2i_ex() function does not check whether the oct\nparameter is NULL before dereferencing it. When called from\nPKCS12_unpack_p7encdata() with a malformed PKCS#12 file, this parameter can\nbe NULL, causing a crash. The vulnerability is limited to Denial of Service\nand cannot be escalated to achieve code execution or memory disclosure.\n\nExploiting this issue requires an attacker to provide a malformed PKCS#12 file\nto an application that processes it. For that reason the issue was assessed as\nLow severity according to our Security Policy.\n\nThe FIPS modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,\nas the PKCS#12 implementation is outside the OpenSSL FIPS module boundary.\n\nOpenSSL 3.6, 3.5, 3.4, 3.3, 3.0, 1.1.1 and 1.0.2 are vulnerable to this issue.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: memory exhaustion via crafted Graphics Execution Manager (GEM) objects",
    "cve": "CVE-2013-7445",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "The Direct Rendering Manager (DRM) subsystem in the Linux kernel through 4.x mishandles requests for Graphics Execution Manager (GEM) objects, which allows context-dependent attackers to cause a denial of service (memory consumption) via an application that processes graphics data, as demonstrated by JavaScript code that creates many CANVAS elements for rendering by Chrome or Firefox.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: mounting a crafted f2fs filesystem image can lead to slab-out-of-bounds read access in f2fs_build_segment_manager in fs/f2fs/segment.c",
    "cve": "CVE-2019-19449",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can lead to slab-out-of-bounds read access in f2fs_build_segment_manager in fs/f2fs/segment.c, related to init_min_max_mtime in fs/f2fs/segment.c (because the second argument to get_seg_entry is not validated).",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: out-of-bounds write in __remove_dirty_segment in fs/f2fs/segment.c",
    "cve": "CVE-2019-19814",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause __remove_dirty_segment slab-out-of-bounds write access because an array is bounded by the number of dirty types (8) but the array index can exceed this.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: low-privileged user privileges escalation",
    "cve": "CVE-2021-3847",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "An unauthorized access to the execution of the setuid file with capabilities flaw in the Linux kernel OverlayFS subsystem was found in the way user copying a capable file from a nosuid mount into another mount. A local user could use this flaw to escalate their privileges on the system.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: descendant's dumpable setting with certain SUID binaries",
    "cve": "CVE-2021-3864",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "A flaw was found in the way the dumpable flag setting was handled when certain SUID binaries executed its descendants. The prerequisite is a SUID binary that sets real UID equal to effective UID, and real GID equal to effective GID. The descendant will then have a dumpable value set to 1. As a result, if the descendant process crashes and core_pattern is set to a relative value, its core dump is stored in the current directory with uid:gid permissions. An unprivileged local user with eligible root SUID binary could use this flaw to place core dumps into root-owned directories, potentially resulting in escalation of privileges.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: bluetooth: use-after-free vulnerability in af_bluetooth.c",
    "cve": "CVE-2024-21803",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "Use After Free vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (bluetooth modules) allows Local Execution of Code. This vulnerability is associated with program files https://gitee.Com/anolis/cloud-kernel/blob/devel-5.10/net/bluetooth/af_bluetooth.C.\n\nThis issue affects Linux kernel: from v2.6.12-rc2 before v6.8-rc1.\n\n",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: wifi: ath12k: Fix for out-of bound access error",
    "cve": "CVE-2024-58015",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath12k: Fix for out-of bound access error\n\nSelfgen stats are placed in a buffer using print_array_to_buf_index() function.\nArray length parameter passed to the function is too big, resulting in possible\nout-of bound memory error.\nDecreasing buffer size by one fixes faulty upper bound of passed array.\n\nDiscovered in coverity scan, CID 1600742 and CID 1600758",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: Linux kernel: PCI/ASPM use-after-free during hot-unplug",
    "cve": "CVE-2024-58093",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI/ASPM: Fix link state exit during switch upstream function removal\n\nBefore 456d8aa37d0f (\"PCI/ASPM: Disable ASPM on MFD function removal to\navoid use-after-free\"), we would free the ASPM link only after the last\nfunction on the bus pertaining to the given link was removed.\n\nThat was too late. If function 0 is removed before sibling function,\nlink->downstream would point to free'd memory after.\n\nAfter above change, we freed the ASPM parent link state upon any function\nremoval on the bus pertaining to a given link.\n\nThat is too early. If the link is to a PCIe switch with MFD on the upstream\nport, then removing functions other than 0 first would free a link which\nstill remains parent_link to the remaining downstream ports.\n\nThe resulting GPFs are especially frequent during hot-unplug, because\npciehp removes devices on the link bus in reverse order.\n\nOn that switch, function 0 is the virtual P2P bridge to the internal bus.\nFree exactly when function 0 is removed -- before the parent link is\nobsolete, but after all subordinate links are gone.\n\n[kwilczynski: commit log]",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: ibmvnic: Use kernel helpers for hex dumps",
    "cve": "CVE-2025-22104",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nibmvnic: Use kernel helpers for hex dumps\n\nPreviously, when the driver was printing hex dumps, the buffer was cast\nto an 8 byte long and printed using string formatters. If the buffer\nsize was not a multiple of 8 then a read buffer overflow was possible.\n\nTherefore, create a new ibmvnic function that loops over a buffer and\ncalls hex_dump_to_buffer instead.\n\nThis patch address KASAN reports like the one below:\n  ibmvnic 30000003 env3: Login Buffer:\n  ibmvnic 30000003 env3: 01000000af000000\n  <...>\n  ibmvnic 30000003 env3: 2e6d62692e736261\n  ibmvnic 30000003 env3: 65050003006d6f63\n  ==================================================================\n  BUG: KASAN: slab-out-of-bounds in ibmvnic_login+0xacc/0xffc [ibmvnic]\n  Read of size 8 at addr c0000001331a9aa8 by task ip/17681\n  <...>\n  Allocated by task 17681:\n  <...>\n  ibmvnic_login+0x2f0/0xffc [ibmvnic]\n  ibmvnic_open+0x148/0x308 [ibmvnic]\n  __dev_open+0x1ac/0x304\n  <...>\n  The buggy address is located 168 bytes inside of\n                allocated 175-byte region [c0000001331a9a00, c0000001331a9aaf)\n  <...>\n  =================================================================\n  ibmvnic 30000003 env3: 000000000033766e",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: PCI/pwrctrl: Cancel outstanding rescan work when unregistering",
    "cve": "CVE-2025-38137",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI/pwrctrl: Cancel outstanding rescan work when unregistering\n\nIt's possible to trigger use-after-free here by:\n\n  (a) forcing rescan_work_func() to take a long time and\n  (b) utilizing a pwrctrl driver that may be unloaded for some reason\n\nCancel outstanding work to ensure it is finished before we allow our data\nstructures to be cleaned up.\n\n[bhelgaas: tidy commit log]",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: drm/nouveau: fix a use-after-free in r535_gsp_rpc_push()",
    "cve": "CVE-2025-38187",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/nouveau: fix a use-after-free in r535_gsp_rpc_push()\n\nThe RPC container is released after being passed to r535_gsp_rpc_send().\n\nWhen sending the initial fragment of a large RPC and passing the\ncaller's RPC container, the container will be freed prematurely. Subsequent\nattempts to send remaining fragments will therefore result in a\nuse-after-free.\n\nAllocate a temporary RPC container for holding the initial fragment of a\nlarge RPC when sending. Free the caller's container when all fragments\nare successfully sent.\n\n[ Rebase onto Blackwell changes. - Danilo ]",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: jfs: fix array-index-out-of-bounds read in add_missing_indices",
    "cve": "CVE-2025-38204",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix array-index-out-of-bounds read in add_missing_indices\n\nstbl is s8 but it must contain offsets into slot which can go from 0 to\n127.\n\nAdded a bound check for that error and return -EIO if the check fails.\nAlso make jfs_readdir return with error if add_missing_indices returns\nwith an error.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: Kernel: Double free vulnerability in exFAT filesystem can lead to denial of service",
    "cve": "CVE-2025-38206",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nexfat: fix double free in delayed_free\n\nThe double free could happen in the following path.\n\nexfat_create_upcase_table()\n        exfat_create_upcase_table() : return error\n        exfat_free_upcase_table() : free ->vol_utbl\n        exfat_load_default_upcase_table : return error\n     exfat_kill_sb()\n           delayed_free()\n                  exfat_free_upcase_table() <--------- double free\nThis patch set ->vol_util as NULL after freeing it.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: Linux kernel:A use-after-free in bridge multicast in br_multicast_port_ctx_init",
    "cve": "CVE-2025-38248",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbridge: mcast: Fix use-after-free during router port configuration\n\nThe bridge maintains a global list of ports behind which a multicast\nrouter resides. The list is consulted during forwarding to ensure\nmulticast packets are forwarded to these ports even if the ports are not\nmember in the matching MDB entry.\n\nWhen per-VLAN multicast snooping is enabled, the per-port multicast\ncontext is disabled on each port and the port is removed from the global\nrouter port list:\n\n # ip link add name br1 up type bridge vlan_filtering 1 mcast_snooping 1\n # ip link add name dummy1 up master br1 type dummy\n # ip link set dev dummy1 type bridge_slave mcast_router 2\n $ bridge -d mdb show | grep router\n router ports on br1: dummy1\n # ip link set dev br1 type bridge mcast_vlan_snooping 1\n $ bridge -d mdb show | grep router\n\nHowever, the port can be re-added to the global list even when per-VLAN\nmulticast snooping is enabled:\n\n # ip link set dev dummy1 type bridge_slave mcast_router 0\n # ip link set dev dummy1 type bridge_slave mcast_router 2\n $ bridge -d mdb show | grep router\n router ports on br1: dummy1\n\nSince commit 4b30ae9adb04 (\"net: bridge: mcast: re-implement\nbr_multicast_{enable, disable}_port functions\"), when per-VLAN multicast\nsnooping is enabled, multicast disablement on a port will disable the\nper-{port, VLAN} multicast contexts and not the per-port one. As a\nresult, a port will remain in the global router port list even after it\nis deleted. This will lead to a use-after-free [1] when the list is\ntraversed (when adding a new port to the list, for example):\n\n # ip link del dev dummy1\n # ip link add name dummy2 up master br1 type dummy\n # ip link set dev dummy2 type bridge_slave mcast_router 2\n\nSimilarly, stale entries can also be found in the per-VLAN router port\nlist. When per-VLAN multicast snooping is disabled, the per-{port, VLAN}\ncontexts are disabled on each port and the port is removed from the\nper-VLAN router port list:\n\n # ip link add name br1 up type bridge vlan_filtering 1 mcast_snooping 1 mcast_vlan_snooping 1\n # ip link add name dummy1 up master br1 type dummy\n # bridge vlan add vid 2 dev dummy1\n # bridge vlan global set vid 2 dev br1 mcast_snooping 1\n # bridge vlan set vid 2 dev dummy1 mcast_router 2\n $ bridge vlan global show dev br1 vid 2 | grep router\n       router ports: dummy1\n # ip link set dev br1 type bridge mcast_vlan_snooping 0\n $ bridge vlan global show dev br1 vid 2 | grep router\n\nHowever, the port can be re-added to the per-VLAN list even when\nper-VLAN multicast snooping is disabled:\n\n # bridge vlan set vid 2 dev dummy1 mcast_router 0\n # bridge vlan set vid 2 dev dummy1 mcast_router 2\n $ bridge vlan global show dev br1 vid 2 | grep router\n       router ports: dummy1\n\nWhen the VLAN is deleted from the port, the per-{port, VLAN} multicast\ncontext will not be disabled since multicast snooping is not enabled\non the VLAN. As a result, the port will remain in the per-VLAN router\nport list even after it is no longer member in the VLAN. This will lead\nto a use-after-free [2] when the list is traversed (when adding a new\nport to the list, for example):\n\n # ip link add name dummy2 up master br1 type dummy\n # bridge vlan add vid 2 dev dummy2\n # bridge vlan del vid 2 dev dummy1\n # bridge vlan set vid 2 dev dummy2 mcast_router 2\n\nFix these issues by removing the port from the relevant (global or\nper-VLAN) router port list in br_multicast_port_ctx_deinit(). The\nfunction is invoked during port deletion with the per-port multicast\ncontext and during VLAN deletion with the per-{port, VLAN} multicast\ncontext.\n\nNote that deleting the multicast router timer is not enough as it only\ntakes care of the temporary multicast router states (1 or 3) and not the\npermanent one (2).\n\n[1]\nBUG: KASAN: slab-out-of-bounds in br_multicast_add_router.part.0+0x3f1/0x560\nWrite of size 8 at addr ffff888004a67328 by task ip/384\n[...]\nCall Trace:\n <TASK>\n dump_stack\n---truncated---",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: platform/x86/amd: pmf: Use device managed allocations",
    "cve": "CVE-2025-38421",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/x86/amd: pmf: Use device managed allocations\n\nIf setting up smart PC fails for any reason then this can lead to\na double free when unloading amd-pmf.  This is because dev->buf was\nfreed but never set to NULL and is again freed in amd_pmf_remove().\n\nTo avoid subtle allocation bugs in failures leading to a double free\nchange all allocations into device managed allocations.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: padata: Fix pd UAF once and for all",
    "cve": "CVE-2025-38584",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npadata: Fix pd UAF once and for all\n\nThere is a race condition/UAF in padata_reorder that goes back\nto the initial commit.  A reference count is taken at the start\nof the process in padata_do_parallel, and released at the end in\npadata_serial_worker.\n\nThis reference count is (and only is) required for padata_replace\nto function correctly.  If padata_replace is never called then\nthere is no issue.\n\nIn the function padata_reorder which serves as the core of padata,\nas soon as padata is added to queue->serial.list, and the associated\nspin lock released, that padata may be processed and the reference\ncount on pd would go away.\n\nFix this by getting the next padata before the squeue->serial lock\nis released.\n\nIn order to make this possible, simplify padata_reorder by only\ncalling it once the next padata arrives.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: f2fs: compress: fix UAF of f2fs_inode_info in f2fs_free_dic",
    "cve": "CVE-2025-38627",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: compress: fix UAF of f2fs_inode_info in f2fs_free_dic\n\nThe decompress_io_ctx may be released asynchronously after\nI/O completion. If this file is deleted immediately after read,\nand the kworker of processing post_read_wq has not been executed yet\ndue to high workloads, It is possible that the inode(f2fs_inode_info)\nis evicted and freed before it is used f2fs_free_dic.\n\n    The UAF case as below:\n    Thread A                                      Thread B\n    - f2fs_decompress_end_io\n     - f2fs_put_dic\n      - queue_work\n        add free_dic work to post_read_wq\n                                                   - do_unlink\n                                                    - iput\n                                                     - evict\n                                                      - call_rcu\n    This file is deleted after read.\n\n    Thread C                                 kworker to process post_read_wq\n    - rcu_do_batch\n     - f2fs_free_inode\n      - kmem_cache_free\n     inode is freed by rcu\n                                             - process_scheduled_works\n                                              - f2fs_late_free_dic\n                                               - f2fs_free_dic\n                                                - f2fs_release_decomp_mem\n                                      read (dic->inode)->i_compress_algorithm\n\nThis patch store compress_algorithm and sbi in dic to avoid inode UAF.\n\nIn addition, the previous solution is deprecated in [1] may cause system hang.\n[1] https://lore.kernel.org/all/c36ab955-c8db-4a8b-a9d0-f07b5f426c3f@kernel.org",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: rv: Use strings in da monitors tracepoints",
    "cve": "CVE-2025-38636",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrv: Use strings in da monitors tracepoints\n\nUsing DA monitors tracepoints with KASAN enabled triggers the following\nwarning:\n\n BUG: KASAN: global-out-of-bounds in do_trace_event_raw_event_event_da_monitor+0xd6/0x1a0\n Read of size 32 at addr ffffffffaada8980 by task ...\n Call Trace:\n  <TASK>\n [...]\n  do_trace_event_raw_event_event_da_monitor+0xd6/0x1a0\n  ? __pfx_do_trace_event_raw_event_event_da_monitor+0x10/0x10\n  ? trace_event_sncid+0x83/0x200\n  trace_event_sncid+0x163/0x200\n [...]\n The buggy address belongs to the variable:\n  automaton_snep+0x4e0/0x5e0\n\nThis is caused by the tracepoints reading 32 bytes __array instead of\n__string from the automata definition. Such strings are literals and\nreading 32 bytes ends up in out of bound memory accesses (e.g. the next\nautomaton's data in this case).\nThe error is harmless as, while printing the string, we stop at the null\nterminator, but it should still be fixed.\n\nUse the __string facilities while defining the tracepoints to avoid\nreading out of bound memory.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: ptp: ocp: fix use-after-free bugs causing by ptp_ocp_watchdog",
    "cve": "CVE-2025-39859",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nptp: ocp: fix use-after-free bugs causing by ptp_ocp_watchdog\n\nThe ptp_ocp_detach() only shuts down the watchdog timer if it is\npending. However, if the timer handler is already running, the\ntimer_delete_sync() is not called. This leads to race conditions\nwhere the devlink that contains the ptp_ocp is deallocated while\nthe timer handler is still accessing it, resulting in use-after-free\nbugs. The following details one of the race scenarios.\n\n(thread 1)                           | (thread 2)\nptp_ocp_remove()                     |\n  ptp_ocp_detach()                   | ptp_ocp_watchdog()\n    if (timer_pending(&bp->watchdog))|   bp = timer_container_of()\n      timer_delete_sync()            |\n                                     |\n  devlink_free(devlink) //free       |\n                                     |   bp-> //use\n\nResolve this by unconditionally calling timer_delete_sync() to ensure\nthe timer is reliably deactivated, preventing any access after free.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: wifi: mt76: mt7915: fix list corruption after hardware restart",
    "cve": "CVE-2025-39862",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mt76: mt7915: fix list corruption after hardware restart\n\nSince stations are recreated from scratch, all lists that wcids are added\nto must be cleared before calling ieee80211_restart_hw.\nSet wcid->sta = 0 for each wcid entry in order to ensure that they are\nnot added again before they are ready.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: iommu/s390: Make attach succeed when the device was surprise removed",
    "cve": "CVE-2025-39958",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/s390: Make attach succeed when the device was surprise removed\n\nWhen a PCI device is removed with surprise hotplug, there may still be\nattempts to attach the device to the default domain as part of tear down\nvia (__iommu_release_dma_ownership()), or because the removal happens\nduring probe (__iommu_probe_device()). In both cases zpci_register_ioat()\nfails with a cc value indicating that the device handle is invalid. This\nis because the device is no longer part of the instance as far as the\nhypervisor is concerned.\n\nCurrently this leads to an error return and s390_iommu_attach_device()\nfails. This triggers the WARN_ON() in __iommu_group_set_domain_nofail()\nbecause attaching to the default domain must never fail.\n\nWith the device fenced by the hypervisor no DMAs to or from memory are\npossible and the IOMMU translations have no effect. Proceed as if the\nregistration was successful and let the hotplug event handling clean up\nthe device.\n\nThis is similar to how devices in the error state are handled since\ncommit 59bbf596791b (\"iommu/s390: Make attach succeed even if the device\nis in error state\") except that for removal the domain will not be\nregistered later. This approach was also previously discussed at the\nlink.\n\nHandle both cases, error state and removal, in a helper which checks if\nthe error needs to be propagated or ignored. Avoid magic number\ncondition codes by using the pre-existing, but never used, defines for\nPCI load/store condition codes and rename them to reflect that they\napply to all PCI instructions.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: smc: Fix use-after-free in __pnet_find_base_ndev()",
    "cve": "CVE-2025-40064",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmc: Fix use-after-free in __pnet_find_base_ndev().\n\nsyzbot reported use-after-free of net_device in __pnet_find_base_ndev(),\nwhich was called during connect(). [0]\n\nsmc_pnet_find_ism_resource() fetches sk_dst_get(sk)->dev and passes\ndown to pnet_find_base_ndev(), where RTNL is held.  Then, UAF happened\nat __pnet_find_base_ndev() when the dev is first used.\n\nThis means dev had already been freed before acquiring RTNL in\npnet_find_base_ndev().\n\nWhile dev is going away, dst->dev could be swapped with blackhole_netdev,\nand the dev's refcnt by dst will be released.\n\nWe must hold dev's refcnt before calling smc_pnet_find_ism_resource().\n\nAlso, smc_pnet_find_roce_resource() has the same problem.\n\nLet's use __sk_dst_get() and dst_dev_rcu() in the two functions.\n\n[0]:\nBUG: KASAN: use-after-free in __pnet_find_base_ndev+0x1b1/0x1c0 net/smc/smc_pnet.c:926\nRead of size 1 at addr ffff888036bac33a by task syz.0.3632/18609\n\nCPU: 1 UID: 0 PID: 18609 Comm: syz.0.3632 Not tainted syzkaller #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/18/2025\nCall Trace:\n <TASK>\n dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xca/0x240 mm/kasan/report.c:482\n kasan_report+0x118/0x150 mm/kasan/report.c:595\n __pnet_find_base_ndev+0x1b1/0x1c0 net/smc/smc_pnet.c:926\n pnet_find_base_ndev net/smc/smc_pnet.c:946 [inline]\n smc_pnet_find_ism_by_pnetid net/smc/smc_pnet.c:1103 [inline]\n smc_pnet_find_ism_resource+0xef/0x390 net/smc/smc_pnet.c:1154\n smc_find_ism_device net/smc/af_smc.c:1030 [inline]\n smc_find_proposal_devices net/smc/af_smc.c:1115 [inline]\n __smc_connect+0x372/0x1890 net/smc/af_smc.c:1545\n smc_connect+0x877/0xd90 net/smc/af_smc.c:1715\n __sys_connect_file net/socket.c:2086 [inline]\n __sys_connect+0x313/0x440 net/socket.c:2105\n __do_sys_connect net/socket.c:2111 [inline]\n __se_sys_connect net/socket.c:2108 [inline]\n __x64_sys_connect+0x7a/0x90 net/socket.c:2108\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f47cbf8eba9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f47ccdb1038 EFLAGS: 00000246 ORIG_RAX: 000000000000002a\nRAX: ffffffffffffffda RBX: 00007f47cc1d5fa0 RCX: 00007f47cbf8eba9\nRDX: 0000000000000010 RSI: 0000200000000280 RDI: 000000000000000b\nRBP: 00007f47cc011e19 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007f47cc1d6038 R14: 00007f47cc1d5fa0 R15: 00007ffc512f8aa8\n </TASK>\n\nThe buggy address belongs to the physical page:\npage: refcount:0 mapcount:0 mapping:0000000000000000 index:0xffff888036bacd00 pfn:0x36bac\nflags: 0xfff00000000000(node=0|zone=1|lastcpupid=0x7ff)\nraw: 00fff00000000000 ffffea0001243d08 ffff8880b863fdc0 0000000000000000\nraw: ffff888036bacd00 0000000000000000 00000000ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as freed\npage last allocated via order 2, migratetype Unmovable, gfp_mask 0x446dc0(GFP_KERNEL_ACCOUNT|__GFP_ZERO|__GFP_NOWARN|__GFP_RETRY_MAYFAIL|__GFP_COMP), pid 16741, tgid 16741 (syz-executor), ts 343313197788, free_ts 380670750466\n set_page_owner include/linux/page_owner.h:32 [inline]\n post_alloc_hook+0x240/0x2a0 mm/page_alloc.c:1851\n prep_new_page mm/page_alloc.c:1859 [inline]\n get_page_from_freelist+0x21e4/0x22c0 mm/page_alloc.c:3858\n __alloc_frozen_pages_noprof+0x181/0x370 mm/page_alloc.c:5148\n alloc_pages_mpol+0x232/0x4a0 mm/mempolicy.c:2416\n ___kmalloc_large_node+0x5f/0x1b0 mm/slub.c:4317\n __kmalloc_large_node_noprof+0x18/0x90 mm/slub.c:4348\n __do_kmalloc_node mm/slub.c:4364 [inline]\n __kvmalloc_node\n---truncated---",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: ipv6: use RCU in ip6_xmit()",
    "cve": "CVE-2025-40135",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: use RCU in ip6_xmit()\n\nUse RCU in ip6_xmit() in order to use dst_dev_rcu() to prevent\npossible UAF.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: ipv6: use RCU in ip6_output()",
    "cve": "CVE-2025-40158",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: use RCU in ip6_output()\n\nUse RCU in ip6_output() in order to use dst_dev_rcu() to prevent\npossible UAF.\n\nWe can remove rcu_read_lock()/rcu_read_unlock() pairs\nfrom ip6_finish_output2().",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: smc: Use __sk_dst_get() and dst_dev_rcu() in smc_clc_prfx_match()",
    "cve": "CVE-2025-40168",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmc: Use __sk_dst_get() and dst_dev_rcu() in smc_clc_prfx_match().\n\nsmc_clc_prfx_match() is called from smc_listen_work() and\nnot under RCU nor RTNL.\n\nUsing sk_dst_get(sk)->dev could trigger UAF.\n\nLet's use __sk_dst_get() and dst_dev_rcu().\n\nNote that the returned value of smc_clc_prfx_match() is not\nused in the caller.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: net: use dst_dev_rcu() in sk_setup_caps()",
    "cve": "CVE-2025-40170",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: use dst_dev_rcu() in sk_setup_caps()\n\nUse RCU to protect accesses to dst->dev from sk_setup_caps()\nand sk_dst_gso_max_size().\n\nAlso use dst_dev_rcu() in ip6_dst_mtu_maybe_forward(),\nand ip_dst_mtu_maybe_forward().\n\nip4_dst_hoplimit() can use dst_dev_net_rcu().",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: mlxsw: spectrum_mr: Fix use-after-free when updating multicast route stats",
    "cve": "CVE-2025-68800",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: spectrum_mr: Fix use-after-free when updating multicast route stats\n\nCited commit added a dedicated mutex (instead of RTNL) to protect the\nmulticast route list, so that it will not change while the driver\nperiodically traverses it in order to update the kernel about multicast\nroute stats that were queried from the device.\n\nOne instance of list entry deletion (during route replace) was missed\nand it can result in a use-after-free [1].\n\nFix by acquiring the mutex before deleting the entry from the list and\nreleasing it afterwards.\n\n[1]\nBUG: KASAN: slab-use-after-free in mlxsw_sp_mr_stats_update+0x4a5/0x540 drivers/net/ethernet/mellanox/mlxsw/spectrum_mr.c:1006 [mlxsw_spectrum]\nRead of size 8 at addr ffff8881523c2fa8 by task kworker/2:5/22043\n\nCPU: 2 UID: 0 PID: 22043 Comm: kworker/2:5 Not tainted 6.18.0-rc1-custom-g1a3d6d7cd014 #1 PREEMPT(full)\nHardware name: Mellanox Technologies Ltd. MSN2010/SA002610, BIOS 5.6.5 08/24/2017\nWorkqueue: mlxsw_core mlxsw_sp_mr_stats_update [mlxsw_spectrum]\nCall Trace:\n <TASK>\n dump_stack_lvl+0xba/0x110\n print_report+0x174/0x4f5\n kasan_report+0xdf/0x110\n mlxsw_sp_mr_stats_update+0x4a5/0x540 drivers/net/ethernet/mellanox/mlxsw/spectrum_mr.c:1006 [mlxsw_spectrum]\n process_one_work+0x9cc/0x18e0\n worker_thread+0x5df/0xe40\n kthread+0x3b8/0x730\n ret_from_fork+0x3e9/0x560\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nAllocated by task 29933:\n kasan_save_stack+0x30/0x50\n kasan_save_track+0x14/0x30\n __kasan_kmalloc+0x8f/0xa0\n mlxsw_sp_mr_route_add+0xd8/0x4770 [mlxsw_spectrum]\n mlxsw_sp_router_fibmr_event_work+0x371/0xad0 drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:7965 [mlxsw_spectrum]\n process_one_work+0x9cc/0x18e0\n worker_thread+0x5df/0xe40\n kthread+0x3b8/0x730\n ret_from_fork+0x3e9/0x560\n ret_from_fork_asm+0x1a/0x30\n\nFreed by task 29933:\n kasan_save_stack+0x30/0x50\n kasan_save_track+0x14/0x30\n __kasan_save_free_info+0x3b/0x70\n __kasan_slab_free+0x43/0x70\n kfree+0x14e/0x700\n mlxsw_sp_mr_route_add+0x2dea/0x4770 drivers/net/ethernet/mellanox/mlxsw/spectrum_mr.c:444 [mlxsw_spectrum]\n mlxsw_sp_router_fibmr_event_work+0x371/0xad0 drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:7965 [mlxsw_spectrum]\n process_one_work+0x9cc/0x18e0\n worker_thread+0x5df/0xe40\n kthread+0x3b8/0x730\n ret_from_fork+0x3e9/0x560\n ret_from_fork_asm+0x1a/0x30",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: svcrdma: use rc_pageoff for memcpy byte offset",
    "cve": "CVE-2025-68811",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsvcrdma: use rc_pageoff for memcpy byte offset\n\nsvc_rdma_copy_inline_range added rc_curpage (page index) to the page\nbase instead of the byte offset rc_pageoff. Use rc_pageoff so copies\nland within the current page.\n\nFound by ZeroPath (https://zeropath.com)",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: ipv6: BUG() in pskb_expand_head() as part of calipso_skbuff_setattr()",
    "cve": "CVE-2025-71085",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: BUG() in pskb_expand_head() as part of calipso_skbuff_setattr()\n\nThere exists a kernel oops caused by a BUG_ON(nhead < 0) at\nnet/core/skbuff.c:2232 in pskb_expand_head().\nThis bug is triggered as part of the calipso_skbuff_setattr()\nroutine when skb_cow() is passed headroom > INT_MAX\n(i.e. (int)(skb_headroom(skb) + len_delta) < 0).\n\nThe root cause of the bug is due to an implicit integer cast in\n__skb_cow(). The check (headroom > skb_headroom(skb)) is meant to ensure\nthat delta = headroom - skb_headroom(skb) is never negative, otherwise\nwe will trigger a BUG_ON in pskb_expand_head(). However, if\nheadroom > INT_MAX and delta <= -NET_SKB_PAD, the check passes, delta\nbecomes negative, and pskb_expand_head() is passed a negative value for\nnhead.\n\nFix the trigger condition in calipso_skbuff_setattr(). Avoid passing\n\"negative\" headroom sizes to skb_cow() within calipso_skbuff_setattr()\nby only using skb_cow() to grow headroom.\n\nPoC:\n\tUsing `netlabelctl` tool:\n\n        netlabelctl map del default\n        netlabelctl calipso add pass doi:7\n        netlabelctl map add default address:0::1/128 protocol:calipso,7\n\n        Then run the following PoC:\n\n        int fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n\n        // setup msghdr\n        int cmsg_size = 2;\n        int cmsg_len = 0x60;\n        struct msghdr msg;\n        struct sockaddr_in6 dest_addr;\n        struct cmsghdr * cmsg = (struct cmsghdr *) calloc(1,\n                        sizeof(struct cmsghdr) + cmsg_len);\n        msg.msg_name = &dest_addr;\n        msg.msg_namelen = sizeof(dest_addr);\n        msg.msg_iov = NULL;\n        msg.msg_iovlen = 0;\n        msg.msg_control = cmsg;\n        msg.msg_controllen = cmsg_len;\n        msg.msg_flags = 0;\n\n        // setup sockaddr\n        dest_addr.sin6_family = AF_INET6;\n        dest_addr.sin6_port = htons(31337);\n        dest_addr.sin6_flowinfo = htonl(31337);\n        dest_addr.sin6_addr = in6addr_loopback;\n        dest_addr.sin6_scope_id = 31337;\n\n        // setup cmsghdr\n        cmsg->cmsg_len = cmsg_len;\n        cmsg->cmsg_level = IPPROTO_IPV6;\n        cmsg->cmsg_type = IPV6_HOPOPTS;\n        char * hop_hdr = (char *)cmsg + sizeof(struct cmsghdr);\n        hop_hdr[1] = 0x9; //set hop size - (0x9 + 1) * 8 = 80\n\n        sendmsg(fd, &msg, 0);",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: libceph: make decode_pool() more resilient against corrupted osdmaps",
    "cve": "CVE-2025-71116",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlibceph: make decode_pool() more resilient against corrupted osdmaps\n\nIf the osdmap is (maliciously) corrupted such that the encoded length\nof ceph_pg_pool envelope is less than what is expected for a particular\nencoding version, out-of-bounds reads may ensue because the only bounds\ncheck that is there is based on that length value.\n\nThis patch adds explicit bounds checks for each field that is decoded\nor skipped.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: libceph: prevent potential out-of-bounds reads in handle_auth_done()",
    "cve": "CVE-2026-22984",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlibceph: prevent potential out-of-bounds reads in handle_auth_done()\n\nPerform an explicit bounds check on payload_len to avoid a possible\nout-of-bounds access in the callout.\n\n[ idryomov: changelog ]",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: libceph: replace overzealous BUG_ON in osdmap_apply_incremental()",
    "cve": "CVE-2026-22990",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlibceph: replace overzealous BUG_ON in osdmap_apply_incremental()\n\nIf the osdmap is (maliciously) corrupted such that the incremental\nosdmap epoch is different from what is expected, there is no need to\nBUG.  Instead, just declare the incremental osdmap to be invalid.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: macvlan: fix possible UAF in macvlan_forward_source()",
    "cve": "CVE-2026-23001",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmacvlan: fix possible UAF in macvlan_forward_source()\n\nAdd RCU protection on (struct macvlan_source_entry)->vlan.\n\nWhenever macvlan_hash_del_source() is called, we must clear\nentry->vlan pointer before RCU grace period starts.\n\nThis allows macvlan_forward_source() to skip over\nentries queued for freeing.\n\nNote that macvlan_dev are already RCU protected, as they\nare embedded in a standard netdev (netdev_priv(ndev)).\n\nhttps: //lore.kernel.org/netdev/695fb1e8.050a0220.1c677c.039f.GAE@google.com/T/#u",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: Linux kernel: Use-after-free in IPv6 address deletion may lead to a denial of service",
    "cve": "CVE-2026-23010",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: Fix use-after-free in inet6_addr_del().\n\nsyzbot reported use-after-free of inet6_ifaddr in\ninet6_addr_del(). [0]\n\nThe cited commit accidentally moved ipv6_del_addr() for\nmngtmpaddr before reading its ifp->flags for temporary\naddresses in inet6_addr_del().\n\nLet's move ipv6_del_addr() down to fix the UAF.\n\n[0]:\nBUG: KASAN: slab-use-after-free in inet6_addr_del.constprop.0+0x67a/0x6b0 net/ipv6/addrconf.c:3117\nRead of size 4 at addr ffff88807b89c86c by task syz.3.1618/9593\n\nCPU: 0 UID: 0 PID: 9593 Comm: syz.3.1618 Not tainted syzkaller #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/25/2025\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xcd/0x630 mm/kasan/report.c:482\n kasan_report+0xe0/0x110 mm/kasan/report.c:595\n inet6_addr_del.constprop.0+0x67a/0x6b0 net/ipv6/addrconf.c:3117\n addrconf_del_ifaddr+0x11e/0x190 net/ipv6/addrconf.c:3181\n inet6_ioctl+0x1e5/0x2b0 net/ipv6/af_inet6.c:582\n sock_do_ioctl+0x118/0x280 net/socket.c:1254\n sock_ioctl+0x227/0x6b0 net/socket.c:1375\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:597 [inline]\n __se_sys_ioctl fs/ioctl.c:583 [inline]\n __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:583\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcd/0xf80 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f164cf8f749\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f164de64038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007f164d1e5fa0 RCX: 00007f164cf8f749\nRDX: 0000200000000000 RSI: 0000000000008936 RDI: 0000000000000003\nRBP: 00007f164d013f91 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007f164d1e6038 R14: 00007f164d1e5fa0 R15: 00007ffde15c8288\n </TASK>\n\nAllocated by task 9593:\n kasan_save_stack+0x33/0x60 mm/kasan/common.c:56\n kasan_save_track+0x14/0x30 mm/kasan/common.c:77\n poison_kmalloc_redzone mm/kasan/common.c:397 [inline]\n __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:414\n kmalloc_noprof include/linux/slab.h:957 [inline]\n kzalloc_noprof include/linux/slab.h:1094 [inline]\n ipv6_add_addr+0x4e3/0x2010 net/ipv6/addrconf.c:1120\n inet6_addr_add+0x256/0x9b0 net/ipv6/addrconf.c:3050\n addrconf_add_ifaddr+0x1fc/0x450 net/ipv6/addrconf.c:3160\n inet6_ioctl+0x103/0x2b0 net/ipv6/af_inet6.c:580\n sock_do_ioctl+0x118/0x280 net/socket.c:1254\n sock_ioctl+0x227/0x6b0 net/socket.c:1375\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:597 [inline]\n __se_sys_ioctl fs/ioctl.c:583 [inline]\n __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:583\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcd/0xf80 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 6099:\n kasan_save_stack+0x33/0x60 mm/kasan/common.c:56\n kasan_save_track+0x14/0x30 mm/kasan/common.c:77\n kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:584\n poison_slab_object mm/kasan/common.c:252 [inline]\n __kasan_slab_free+0x5f/0x80 mm/kasan/common.c:284\n kasan_slab_free include/linux/kasan.h:234 [inline]\n slab_free_hook mm/slub.c:2540 [inline]\n slab_free_freelist_hook mm/slub.c:2569 [inline]\n slab_free_bulk mm/slub.c:6696 [inline]\n kmem_cache_free_bulk mm/slub.c:7383 [inline]\n kmem_cache_free_bulk+0x2bf/0x680 mm/slub.c:7362\n kfree_bulk include/linux/slab.h:830 [inline]\n kvfree_rcu_bulk+0x1b7/0x1e0 mm/slab_common.c:1523\n kvfree_rcu_drain_ready mm/slab_common.c:1728 [inline]\n kfree_rcu_monitor+0x1d0/0x2f0 mm/slab_common.c:1801\n process_one_work+0x9ba/0x1b20 kernel/workqueue.c:3257\n process_scheduled_works kernel/workqu\n---truncated---",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: pNFS: Fix a deadlock when returning a delegation during open()",
    "cve": "CVE-2026-23050",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npNFS: Fix a deadlock when returning a delegation during open()\n\nBen Coddington reports seeing a hang in the following stack trace:\n  0 [ffffd0b50e1774e0] __schedule at ffffffff9ca05415\n  1 [ffffd0b50e177548] schedule at ffffffff9ca05717\n  2 [ffffd0b50e177558] bit_wait at ffffffff9ca061e1\n  3 [ffffd0b50e177568] __wait_on_bit at ffffffff9ca05cfb\n  4 [ffffd0b50e1775c8] out_of_line_wait_on_bit at ffffffff9ca05ea5\n  5 [ffffd0b50e177618] pnfs_roc at ffffffffc154207b [nfsv4]\n  6 [ffffd0b50e1776b8] _nfs4_proc_delegreturn at ffffffffc1506586 [nfsv4]\n  7 [ffffd0b50e177788] nfs4_proc_delegreturn at ffffffffc1507480 [nfsv4]\n  8 [ffffd0b50e1777f8] nfs_do_return_delegation at ffffffffc1523e41 [nfsv4]\n  9 [ffffd0b50e177838] nfs_inode_set_delegation at ffffffffc1524a75 [nfsv4]\n 10 [ffffd0b50e177888] nfs4_process_delegation at ffffffffc14f41dd [nfsv4]\n 11 [ffffd0b50e1778a0] _nfs4_opendata_to_nfs4_state at ffffffffc1503edf [nfsv4]\n 12 [ffffd0b50e1778c0] _nfs4_open_and_get_state at ffffffffc1504e56 [nfsv4]\n 13 [ffffd0b50e177978] _nfs4_do_open at ffffffffc15051b8 [nfsv4]\n 14 [ffffd0b50e1779f8] nfs4_do_open at ffffffffc150559c [nfsv4]\n 15 [ffffd0b50e177a80] nfs4_atomic_open at ffffffffc15057fb [nfsv4]\n 16 [ffffd0b50e177ad0] nfs4_file_open at ffffffffc15219be [nfsv4]\n 17 [ffffd0b50e177b78] do_dentry_open at ffffffff9c09e6ea\n 18 [ffffd0b50e177ba8] vfs_open at ffffffff9c0a082e\n 19 [ffffd0b50e177bd0] dentry_open at ffffffff9c0a0935\n\nThe issue is that the delegreturn is being asked to wait for a layout\nreturn that cannot complete because a state recovery was initiated. The\nstate recovery cannot complete until the open() finishes processing the\ndelegations it was given.\n\nThe solution is to propagate the existing flags that indicate a\nnon-blocking call to the function pnfs_roc(), so that it knows not to\nwait in this situation.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: net: hv_netvsc: reject RSS hash key programming without RX indirection table",
    "cve": "CVE-2026-23054",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hv_netvsc: reject RSS hash key programming without RX indirection table\n\nRSS configuration requires a valid RX indirection table. When the device\nreports a single receive queue, rndis_filter_device_add() does not\nallocate an indirection table, accepting RSS hash key updates in this\nstate leads to a hang.\n\nFix this by gating netvsc_set_rxfh() on ndc->rx_table_sz and return\n-EOPNOTSUPP when the table is absent. This aligns set_rxfh with the device\ncapabilities and prevents incorrect behavior.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: vsock/virtio: Coalesce only linear skb",
    "cve": "CVE-2026-23057",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock/virtio: Coalesce only linear skb\n\nvsock/virtio common tries to coalesce buffers in rx queue: if a linear skb\n(with a spare tail room) is followed by a small skb (length limited by\nGOOD_COPY_LEN = 128), an attempt is made to join them.\n\nSince the introduction of MSG_ZEROCOPY support, assumption that a small skb\nwill always be linear is incorrect. In the zerocopy case, data is lost and\nthe linear skb is appended with uninitialized kernel memory.\n\nOf all 3 supported virtio-based transports, only loopback-transport is\naffected. G2H virtio-transport rx queue operates on explicitly linear skbs;\nsee virtio_vsock_alloc_linear_skb() in virtio_vsock_rx_fill(). H2G\nvhost-transport may allocate non-linear skbs, but only for sizes that are\nnot considered for coalescence; see PAGE_ALLOC_COSTLY_ORDER in\nvirtio_vsock_alloc_skb().\n\nEnsure only linear skbs are coalesced. Note that skb_tailroom(last_skb) > 0\nguarantees last_skb is linear.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: scsi: qla2xxx: Sanitize payload size to prevent member overflow",
    "cve": "CVE-2026-23059",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Sanitize payload size to prevent member overflow\n\nIn qla27xx_copy_fpin_pkt() and qla27xx_copy_multiple_pkt(), the frame_size\nreported by firmware is used to calculate the copy length into\nitem->iocb. However, the iocb member is defined as a fixed-size 64-byte\narray within struct purex_item.\n\nIf the reported frame_size exceeds 64 bytes, subsequent memcpy calls will\noverflow the iocb member boundary. While extra memory might be allocated,\nthis cross-member write is unsafe and triggers warnings under\nCONFIG_FORTIFY_SOURCE.\n\nFix this by capping total_bytes to the size of the iocb member (64 bytes)\nbefore allocation and copying. This ensures all copies remain within the\nbounds of the destination structure member.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: Linux kernel: Denial of Service via unsafe requeue in rxrpc_recvmsg",
    "cve": "CVE-2026-23066",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrxrpc: Fix recvmsg() unconditional requeue\n\nIf rxrpc_recvmsg() fails because MSG_DONTWAIT was specified but the call at\nthe front of the recvmsg queue already has its mutex locked, it requeues\nthe call - whether or not the call is already queued.  The call may be on\nthe queue because MSG_PEEK was also passed and so the call was not dequeued\nor because the I/O thread requeued it.\n\nThe unconditional requeue may then corrupt the recvmsg queue, leading to\nthings like UAFs or refcount underruns.\n\nFix this by only requeuing the call if it isn't already on the queue - and\nmoving it to the front if it is already queued.  If we don't queue it, we\nhave to put the ref we obtained by dequeuing it.\n\nAlso, MSG_PEEK doesn't dequeue the call so shouldn't call\nrxrpc_notify_socket() for the call if we didn't use up all the data on the\nqueue, so fix that also.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: Octeontx2-af: Add proper checks for fwdata",
    "cve": "CVE-2026-23070",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nOcteontx2-af: Add proper checks for fwdata\n\nfirmware populates MAC address, link modes (supported, advertised)\nand EEPROM data in shared firmware structure which kernel access\nvia MAC block(CGX/RPM).\n\nAccessing fwdata, on boards booted with out MAC block leading to\nkernel panics.\n\nInternal error: Oops: 0000000096000005 [#1]  SMP\n[   10.460721] Modules linked in:\n[   10.463779] CPU: 0 UID: 0 PID: 174 Comm: kworker/0:3 Not tainted 6.19.0-rc5-00154-g76ec646abdf7-dirty #3 PREEMPT\n[   10.474045] Hardware name: Marvell OcteonTX CN98XX board (DT)\n[   10.479793] Workqueue: events work_for_cpu_fn\n[   10.484159] pstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   10.491124] pc : rvu_sdp_init+0x18/0x114\n[   10.495051] lr : rvu_probe+0xe58/0x1d18",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: Linux kernel: Use-after-free in teql queueing discipline can lead to privilege escalation",
    "cve": "CVE-2026-23074",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Enforce that teql can only be used as root qdisc\n\nDesign intent of teql is that it is only supposed to be used as root qdisc.\nWe need to check for that constraint.\n\nAlthough not important, I will describe the scenario that unearthed this\nissue for the curious.\n\nGangMin Kim <km.kim1503@gmail.com> managed to concot a scenario as follows:\n\nROOT qdisc 1:0 (QFQ)\n  \u251c\u2500\u2500 class 1:1 (weight=15, lmax=16384) netem with delay 6.4s\n  \u2514\u2500\u2500 class 1:2 (weight=1, lmax=1514) teql\n\nGangMin sends a packet which is enqueued to 1:1 (netem).\nAny invocation of dequeue by QFQ from this class will not return a packet\nuntil after 6.4s. In the meantime, a second packet is sent and it lands on\n1:2. teql's enqueue will return success and this will activate class 1:2.\nMain issue is that teql only updates the parent visible qlen (sch->q.qlen)\nat dequeue. Since QFQ will only call dequeue if peek succeeds (and teql's\npeek always returns NULL), dequeue will never be called and thus the qlen\nwill remain as 0. With that in mind, when GangMin updates 1:2's lmax value,\nthe qfq_change_class calls qfq_deact_rm_from_agg. Since the child qdisc's\nqlen was not incremented, qfq fails to deactivate the class, but still\nfrees its pointers from the aggregate. So when the first packet is\nrescheduled after 6.4 seconds (netem's delay), a dangling pointer is\naccessed causing GangMin's causing a UAF.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: be2net: Fix NULL pointer dereference in be_cmd_get_mac_from_list",
    "cve": "CVE-2026-23084",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbe2net: Fix NULL pointer dereference in be_cmd_get_mac_from_list\n\nWhen the parameter pmac_id_valid argument of be_cmd_get_mac_from_list() is\nset to false, the driver may request the PMAC_ID from the firmware of the\nnetwork card, and this function will store that PMAC_ID at the provided\naddress pmac_id. This is the contract of this function.\n\nHowever, there is a location within the driver where both\npmac_id_valid == false and pmac_id == NULL are being passed. This could\nresult in dereferencing a NULL pointer.\n\nTo resolve this issue, it is necessary to pass the address of a stub\nvariable to the function.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: Linux kernel: Denial of Service due to a deadlock in hugetlb folio migration",
    "cve": "CVE-2026-23097",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmigrate: correct lock ordering for hugetlb file folios\n\nSyzbot has found a deadlock (analyzed by Lance Yang):\n\n1) Task (5749): Holds folio_lock, then tries to acquire i_mmap_rwsem(read lock).\n2) Task (5754): Holds i_mmap_rwsem(write lock), then tries to acquire\nfolio_lock.\n\nmigrate_pages()\n  -> migrate_hugetlbs()\n    -> unmap_and_move_huge_page()     <- Takes folio_lock!\n      -> remove_migration_ptes()\n        -> __rmap_walk_file()\n          -> i_mmap_lock_read()       <- Waits for i_mmap_rwsem(read lock)!\n\nhugetlbfs_fallocate()\n  -> hugetlbfs_punch_hole()           <- Takes i_mmap_rwsem(write lock)!\n    -> hugetlbfs_zero_partial_page()\n     -> filemap_lock_hugetlb_folio()\n      -> filemap_lock_folio()\n        -> __filemap_get_folio        <- Waits for folio_lock!\n\nThe migration path is the one taking locks in the wrong order according to\nthe documentation at the top of mm/rmap.c.  So expand the scope of the\nexisting i_mmap_lock to cover the calls to remove_migration_ptes() too.\n\nThis is (mostly) how it used to be after commit c0d0381ade79.  That was\nremoved by 336bf30eb765 for both file & anon hugetlb pages when it should\nonly have been removed for anon hugetlb pages.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: bonding: limit BOND_MODE_8023AD to Ethernet devices",
    "cve": "CVE-2026-23099",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbonding: limit BOND_MODE_8023AD to Ethernet devices\n\nBOND_MODE_8023AD makes sense for ARPHRD_ETHER only.\n\nsyzbot reported:\n\n BUG: KASAN: global-out-of-bounds in __hw_addr_create net/core/dev_addr_lists.c:63 [inline]\n BUG: KASAN: global-out-of-bounds in __hw_addr_add_ex+0x25d/0x760 net/core/dev_addr_lists.c:118\nRead of size 16 at addr ffffffff8bf94040 by task syz.1.3580/19497\n\nCPU: 1 UID: 0 PID: 19497 Comm: syz.1.3580 Tainted: G             L      syzkaller #0 PREEMPT(full)\nTainted: [L]=SOFTLOCKUP\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/25/2025\nCall Trace:\n <TASK>\n  dump_stack_lvl+0xe8/0x150 lib/dump_stack.c:120\n  print_address_description mm/kasan/report.c:378 [inline]\n  print_report+0xca/0x240 mm/kasan/report.c:482\n  kasan_report+0x118/0x150 mm/kasan/report.c:595\n check_region_inline mm/kasan/generic.c:-1 [inline]\n  kasan_check_range+0x2b0/0x2c0 mm/kasan/generic.c:200\n  __asan_memcpy+0x29/0x70 mm/kasan/shadow.c:105\n  __hw_addr_create net/core/dev_addr_lists.c:63 [inline]\n  __hw_addr_add_ex+0x25d/0x760 net/core/dev_addr_lists.c:118\n  __dev_mc_add net/core/dev_addr_lists.c:868 [inline]\n  dev_mc_add+0xa1/0x120 net/core/dev_addr_lists.c:886\n  bond_enslave+0x2b8b/0x3ac0 drivers/net/bonding/bond_main.c:2180\n  do_set_master+0x533/0x6d0 net/core/rtnetlink.c:2963\n  do_setlink+0xcf0/0x41c0 net/core/rtnetlink.c:3165\n  rtnl_changelink net/core/rtnetlink.c:3776 [inline]\n  __rtnl_newlink net/core/rtnetlink.c:3935 [inline]\n  rtnl_newlink+0x161c/0x1c90 net/core/rtnetlink.c:4072\n  rtnetlink_rcv_msg+0x7cf/0xb70 net/core/rtnetlink.c:6958\n  netlink_rcv_skb+0x208/0x470 net/netlink/af_netlink.c:2550\n  netlink_unicast_kernel net/netlink/af_netlink.c:1318 [inline]\n  netlink_unicast+0x82f/0x9e0 net/netlink/af_netlink.c:1344\n  netlink_sendmsg+0x805/0xb30 net/netlink/af_netlink.c:1894\n  sock_sendmsg_nosec net/socket.c:727 [inline]\n  __sock_sendmsg+0x21c/0x270 net/socket.c:742\n  ____sys_sendmsg+0x505/0x820 net/socket.c:2592\n  ___sys_sendmsg+0x21f/0x2a0 net/socket.c:2646\n  __sys_sendmsg+0x164/0x220 net/socket.c:2678\n  do_syscall_32_irqs_on arch/x86/entry/syscall_32.c:83 [inline]\n  __do_fast_syscall_32+0x1dc/0x560 arch/x86/entry/syscall_32.c:307\n  do_fast_syscall_32+0x34/0x80 arch/x86/entry/syscall_32.c:332\n entry_SYSENTER_compat_after_hwframe+0x84/0x8e\n </TASK>\n\nThe buggy address belongs to the variable:\n lacpdu_mcast_addr+0x0/0x40",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "kernel: ipvlan: Make the addrs_lock be per port",
    "cve": "CVE-2026-23103",
    "package": "linux-libc-dev",
    "severity": "HIGH",
    "installed_version": "6.12.63-1",
    "fixed_version": null,
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipvlan: Make the addrs_lock be per port\n\nMake the addrs_lock be per port, not per ipvlan dev.\n\nInitial code seems to be written in the assumption,\nthat any address change must occur under RTNL.\nBut it is not so for the case of IPv6. So\n\n1) Introduce per-port addrs_lock.\n\n2) It was needed to fix places where it was forgotten\nto take lock (ipvlan_open/ipvlan_close)\n\nThis appears to be a very minor problem though.\nSince it's highly unlikely that ipvlan_add_addr() will\nbe called on 2 CPU simultaneously. But nevertheless,\nthis could cause:\n\n1) False-negative of ipvlan_addr_busy(): one interface\niterated through all port->ipvlans + ipvlan->addrs\nunder some ipvlan spinlock, and another added IP\nunder its own lock. Though this is only possible\nfor IPv6, since looks like only ipvlan_addr6_event() can be\ncalled without rtnl_lock.\n\n2) Race since ipvlan_ht_addr_add(port) is called under\ndifferent ipvlan->addrs_lock locks\n\nThis should not affect performance, since add/remove IP\nis a rare situation and spinlock is not taken on fast\npaths.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "glibc: Integer overflow in memalign leads to heap corruption",
    "cve": "CVE-2026-0861",
    "package": "locales",
    "severity": "HIGH",
    "installed_version": "2.41-12+deb13u1",
    "fixed_version": null,
    "description": "Passing too large an alignment to the memalign suite of functions (memalign, posix_memalign, aligned_alloc) in the GNU C Library version 2.30 to 2.42 may result in an integer overflow, which could consequently result in a heap corruption.\n\nNote that the attacker must have control over both, the size as well as the alignment arguments of the memalign function to be able to exploit this.  The size parameter must be close enough to PTRDIFF_MAX so as to overflow size_t along with the large alignment argument.  This limits the malicious inputs for the alignment for memalign to the range [1<<62+ 1, 1<<63] and exactly 1<<63 for posix_memalign and aligned_alloc.\n\nTypically the alignment argument passed to such functions is a known constrained quantity (e.g. page size, block size, struct sizes) and is not attacker controlled, because of which this may not be easily exploitable in practice.  An application bug could potentially result in the input alignment being too large, e.g. due to a different buffer overflow or integer overflow in the application or its dependent libraries, but that is again an uncommon usage pattern given typical sources of alignments.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "undici: Undici: Denial of Service via excessive decompression steps",
    "cve": "CVE-2026-22036",
    "package": "node-undici",
    "severity": "HIGH",
    "installed_version": "7.3.0+dfsg1+~cs24.12.11-1",
    "fixed_version": null,
    "description": "Undici is an HTTP/1.1 client for Node.js. Prior to 7.18.0 and 6.23.0, the number of links in the decompression chain is unbounded and the default maxHeaderSize allows a malicious server to insert thousands compression steps leading to high CPU usage and excessive memory allocation. This vulnerability is fixed in 7.18.0 and 6.23.0.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs uninitialized memory exposure",
    "cve": "CVE-2025-55131",
    "package": "nodejs",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "A flaw in Node.js's buffer allocation logic can expose uninitialized memory when allocations are interrupted, when using the `vm` module with the timeout option. Under specific timing conditions, buffers allocated with `Buffer.alloc` and other `TypedArray` instances like `Uint8Array` may contain leftover data from previous operations, allowing in-process secrets like tokens or passwords to leak or causing data corruption. While exploitation typically requires precise timing or in-process code execution, it can become remotely exploitable when untrusted input influences workload and timeouts, leading to potential confidentiality and integrity impact.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs denial of service",
    "cve": "CVE-2025-59465",
    "package": "nodejs",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "A malformed `HTTP/2 HEADERS` frame with oversized, invalid `HPACK` data can cause Node.js to crash by triggering an unhandled `TLSSocket` error `ECONNRESET`. Instead of safely closing the connection, the process crashes, enabling a remote denial of service. This primarily affects applications that do not attach explicit error handlers to secure sockets, for example:\n```\nserver.on('secureConnection', socket => {\n  socket.on('error', err => {\n    console.log(err)\n  })\n})\n```",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs denial of service",
    "cve": "CVE-2025-59466",
    "package": "nodejs",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "We have identified a bug in Node.js error handling where \"Maximum call stack size exceeded\" errors become uncatchable when `async_hooks.createHook()` is enabled. Instead of reaching `process.on('uncaughtException')`, the process terminates, making the crash unrecoverable. Applications that rely on `AsyncLocalStorage` (v22, v20) or `async_hooks.createHook()` (v24, v22, v20) become vulnerable to denial-of-service crashes triggered by deep recursion under specific conditions.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs denial of service",
    "cve": "CVE-2026-21637",
    "package": "nodejs",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "A flaw in Node.js TLS error handling allows remote attackers to crash or exhaust resources of a TLS server when `pskCallback` or `ALPNCallback` are in use. Synchronous exceptions thrown during these callbacks bypass standard TLS error handling paths (tlsClientError and error), causing either immediate process termination or silent file descriptor leaks that eventually lead to denial of service. Because these callbacks process attacker-controlled input during the TLS handshake, a remote client can repeatedly trigger the issue. This vulnerability affects TLS servers using PSK or ALPN callbacks across Node.js versions where these callbacks throw without being safely wrapped.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs uninitialized memory exposure",
    "cve": "CVE-2025-55131",
    "package": "nodejs-doc",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "A flaw in Node.js's buffer allocation logic can expose uninitialized memory when allocations are interrupted, when using the `vm` module with the timeout option. Under specific timing conditions, buffers allocated with `Buffer.alloc` and other `TypedArray` instances like `Uint8Array` may contain leftover data from previous operations, allowing in-process secrets like tokens or passwords to leak or causing data corruption. While exploitation typically requires precise timing or in-process code execution, it can become remotely exploitable when untrusted input influences workload and timeouts, leading to potential confidentiality and integrity impact.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs denial of service",
    "cve": "CVE-2025-59465",
    "package": "nodejs-doc",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "A malformed `HTTP/2 HEADERS` frame with oversized, invalid `HPACK` data can cause Node.js to crash by triggering an unhandled `TLSSocket` error `ECONNRESET`. Instead of safely closing the connection, the process crashes, enabling a remote denial of service. This primarily affects applications that do not attach explicit error handlers to secure sockets, for example:\n```\nserver.on('secureConnection', socket => {\n  socket.on('error', err => {\n    console.log(err)\n  })\n})\n```",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs denial of service",
    "cve": "CVE-2025-59466",
    "package": "nodejs-doc",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "We have identified a bug in Node.js error handling where \"Maximum call stack size exceeded\" errors become uncatchable when `async_hooks.createHook()` is enabled. Instead of reaching `process.on('uncaughtException')`, the process terminates, making the crash unrecoverable. Applications that rely on `AsyncLocalStorage` (v22, v20) or `async_hooks.createHook()` (v24, v22, v20) become vulnerable to denial-of-service crashes triggered by deep recursion under specific conditions.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "nodejs: Nodejs denial of service",
    "cve": "CVE-2026-21637",
    "package": "nodejs-doc",
    "severity": "HIGH",
    "installed_version": "20.19.2+dfsg-1",
    "fixed_version": null,
    "description": "A flaw in Node.js TLS error handling allows remote attackers to crash or exhaust resources of a TLS server when `pskCallback` or `ALPNCallback` are in use. Synchronous exceptions thrown during these callbacks bypass standard TLS error handling paths (tlsClientError and error), causing either immediate process termination or silent file descriptor leaks that eventually lead to denial of service. Because these callbacks process attacker-controlled input during the TLS handshake, a remote client can repeatedly trigger the issue. This vulnerability affects TLS servers using PSK or ALPN callbacks across Node.js versions where these callbacks throw without being safely wrapped.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "openssl: OpenSSL: Arbitrary code execution due to out-of-bounds write in PKCS#12 processing",
    "cve": "CVE-2025-69419",
    "package": "openssl",
    "severity": "HIGH",
    "installed_version": "3.5.1-1+deb13u1",
    "fixed_version": "3.5.4-1~deb13u2",
    "description": "Issue summary: Calling PKCS12_get_friendlyname() function on a maliciously\ncrafted PKCS#12 file with a BMPString (UTF-16BE) friendly name containing\nnon-ASCII BMP code point can trigger a one byte write before the allocated\nbuffer.\n\nImpact summary: The out-of-bounds write can cause a memory corruption\nwhich can have various consequences including a Denial of Service.\n\nThe OPENSSL_uni2utf8() function performs a two-pass conversion of a PKCS#12\nBMPString (UTF-16BE) to UTF-8. In the second pass, when emitting UTF-8 bytes,\nthe helper function bmp_to_utf8() incorrectly forwards the remaining UTF-16\nsource byte count as the destination buffer capacity to UTF8_putc(). For BMP\ncode points above U+07FF, UTF-8 requires three bytes, but the forwarded\ncapacity can be just two bytes. UTF8_putc() then returns -1, and this negative\nvalue is added to the output length without validation, causing the\nlength to become negative. The subsequent trailing NUL byte is then written\nat a negative offset, causing write outside of heap allocated buffer.\n\nThe vulnerability is reachable via the public PKCS12_get_friendlyname() API\nwhen parsing attacker-controlled PKCS#12 files. While PKCS12_parse() uses a\ndifferent code path that avoids this issue, PKCS12_get_friendlyname() directly\ninvokes the vulnerable function. Exploitation requires an attacker to provide\na malicious PKCS#12 file to be parsed by the application and the attacker\ncan just trigger a one zero byte write before the allocated buffer.\nFor that reason the issue was assessed as Low severity according to our\nSecurity Policy.\n\nThe FIPS modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,\nas the PKCS#12 implementation is outside the OpenSSL FIPS module boundary.\n\nOpenSSL 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.\n\nOpenSSL 1.0.2 is not affected by this issue.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "openssl: OpenSSL: Denial of Service via malformed PKCS#12 file processing",
    "cve": "CVE-2025-69421",
    "package": "openssl",
    "severity": "HIGH",
    "installed_version": "3.5.1-1+deb13u1",
    "fixed_version": "3.5.4-1~deb13u2",
    "description": "Issue summary: Processing a malformed PKCS#12 file can trigger a NULL pointer\ndereference in the PKCS12_item_decrypt_d2i_ex() function.\n\nImpact summary: A NULL pointer dereference can trigger a crash which leads to\nDenial of Service for an application processing PKCS#12 files.\n\nThe PKCS12_item_decrypt_d2i_ex() function does not check whether the oct\nparameter is NULL before dereferencing it. When called from\nPKCS12_unpack_p7encdata() with a malformed PKCS#12 file, this parameter can\nbe NULL, causing a crash. The vulnerability is limited to Denial of Service\nand cannot be escalated to achieve code execution or memory disclosure.\n\nExploiting this issue requires an attacker to provide a malformed PKCS#12 file\nto an application that processes it. For that reason the issue was assessed as\nLow severity according to our Security Policy.\n\nThe FIPS modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,\nas the PKCS#12 implementation is outside the OpenSSL FIPS module boundary.\n\nOpenSSL 3.6, 3.5, 3.4, 3.3, 3.0, 1.1.1 and 1.0.2 are vulnerable to this issue.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "openssl: OpenSSL: Arbitrary code execution due to out-of-bounds write in PKCS#12 processing",
    "cve": "CVE-2025-69419",
    "package": "openssl-provider-legacy",
    "severity": "HIGH",
    "installed_version": "3.5.1-1+deb13u1",
    "fixed_version": "3.5.4-1~deb13u2",
    "description": "Issue summary: Calling PKCS12_get_friendlyname() function on a maliciously\ncrafted PKCS#12 file with a BMPString (UTF-16BE) friendly name containing\nnon-ASCII BMP code point can trigger a one byte write before the allocated\nbuffer.\n\nImpact summary: The out-of-bounds write can cause a memory corruption\nwhich can have various consequences including a Denial of Service.\n\nThe OPENSSL_uni2utf8() function performs a two-pass conversion of a PKCS#12\nBMPString (UTF-16BE) to UTF-8. In the second pass, when emitting UTF-8 bytes,\nthe helper function bmp_to_utf8() incorrectly forwards the remaining UTF-16\nsource byte count as the destination buffer capacity to UTF8_putc(). For BMP\ncode points above U+07FF, UTF-8 requires three bytes, but the forwarded\ncapacity can be just two bytes. UTF8_putc() then returns -1, and this negative\nvalue is added to the output length without validation, causing the\nlength to become negative. The subsequent trailing NUL byte is then written\nat a negative offset, causing write outside of heap allocated buffer.\n\nThe vulnerability is reachable via the public PKCS12_get_friendlyname() API\nwhen parsing attacker-controlled PKCS#12 files. While PKCS12_parse() uses a\ndifferent code path that avoids this issue, PKCS12_get_friendlyname() directly\ninvokes the vulnerable function. Exploitation requires an attacker to provide\na malicious PKCS#12 file to be parsed by the application and the attacker\ncan just trigger a one zero byte write before the allocated buffer.\nFor that reason the issue was assessed as Low severity according to our\nSecurity Policy.\n\nThe FIPS modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,\nas the PKCS#12 implementation is outside the OpenSSL FIPS module boundary.\n\nOpenSSL 3.6, 3.5, 3.4, 3.3, 3.0 and 1.1.1 are vulnerable to this issue.\n\nOpenSSL 1.0.2 is not affected by this issue.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "openssl: OpenSSL: Denial of Service via malformed PKCS#12 file processing",
    "cve": "CVE-2025-69421",
    "package": "openssl-provider-legacy",
    "severity": "HIGH",
    "installed_version": "3.5.1-1+deb13u1",
    "fixed_version": "3.5.4-1~deb13u2",
    "description": "Issue summary: Processing a malformed PKCS#12 file can trigger a NULL pointer\ndereference in the PKCS12_item_decrypt_d2i_ex() function.\n\nImpact summary: A NULL pointer dereference can trigger a crash which leads to\nDenial of Service for an application processing PKCS#12 files.\n\nThe PKCS12_item_decrypt_d2i_ex() function does not check whether the oct\nparameter is NULL before dereferencing it. When called from\nPKCS12_unpack_p7encdata() with a malformed PKCS#12 file, this parameter can\nbe NULL, causing a crash. The vulnerability is limited to Denial of Service\nand cannot be escalated to achieve code execution or memory disclosure.\n\nExploiting this issue requires an attacker to provide a malformed PKCS#12 file\nto an application that processes it. For that reason the issue was assessed as\nLow severity according to our Security Policy.\n\nThe FIPS modules in 3.6, 3.5, 3.4, 3.3 and 3.0 are not affected by this issue,\nas the PKCS#12 implementation is outside the OpenSSL FIPS module boundary.\n\nOpenSSL 3.6, 3.5, 3.4, 3.3, 3.0, 1.1.1 and 1.0.2 are vulnerable to this issue.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "pyasn1: pyasn1: Denial of Service due to memory exhaustion from malformed RELATIVE-OID",
    "cve": "CVE-2026-23490",
    "package": "python3-pyasn1",
    "severity": "HIGH",
    "installed_version": "0.6.1-1",
    "fixed_version": "0.6.1-1+deb13u1",
    "description": "pyasn1 is a generic ASN.1 library for Python. Prior to 0.6.2, a Denial-of-Service issue has been found that leads to memory exhaustion from malformed RELATIVE-OID with excessive continuation octets. This vulnerability is fixed in 0.6.2.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "jaraco.context: jaraco.context: Path traversal via malicious tar archives",
    "cve": "CVE-2026-23949",
    "package": "python3-setuptools-whl",
    "severity": "HIGH",
    "installed_version": "78.1.1-0.1",
    "fixed_version": null,
    "description": "jaraco.context, an open-source software package that provides some useful decorators and context managers, has a Zip Slip path traversal vulnerability in the `jaraco.context.tarball()` function starting in version 5.2.0 and prior to version 6.1.0. The vulnerability may allow attackers to extract files outside the intended extraction directory when malicious tar archives are processed. The strip_first_component filter splits the path on the first `/` and extracts the second component, while allowing `../` sequences. Paths like `dummy_dir/../../etc/passwd` become `../../etc/passwd`. Note that this suffers from a nested tarball attack as well with multi-level tar files such as `dummy_dir/inner.tar.gz`, where the inner.tar.gz includes a traversal `dummy_dir/../../config/.env` that also gets translated to `../../config/.env`. Version 6.1.0 contains a patch for the issue.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "urllib3: urllib3: Unbounded decompression chain leads to resource exhaustion",
    "cve": "CVE-2025-66418",
    "package": "python3-urllib3",
    "severity": "HIGH",
    "installed_version": "2.3.0-3",
    "fixed_version": "2.3.0-3+deb13u1",
    "description": "urllib3 is a user-friendly HTTP client library for Python. Starting in version 1.24 and prior to 2.6.0, the number of links in the decompression chain was unbounded allowing a malicious server to insert a virtually unlimited number of compression steps leading to high CPU usage and massive memory allocation for the decompressed data. This vulnerability is fixed in 2.6.0.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "urllib3: urllib3 Streaming API improperly handles highly compressed data",
    "cve": "CVE-2025-66471",
    "package": "python3-urllib3",
    "severity": "HIGH",
    "installed_version": "2.3.0-3",
    "fixed_version": null,
    "description": "urllib3 is a user-friendly HTTP client library for Python. Starting in version 1.0 and prior to 2.6.0, the Streaming API improperly handles highly compressed data. urllib3's streaming API is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once. When streaming a compressed response, urllib3 can perform decoding or decompression based on the HTTP Content-Encoding header (e.g., gzip, deflate, br, or zstd). The library must read compressed data from the network and decompress it until the requested chunk size is met. Any resulting decompressed data that exceeds the requested amount is held in an internal buffer for the next read operation. The decompression logic could cause urllib3 to fully decode a small amount of highly compressed data in a single operation. This can result in excessive resource consumption (high CPU usage and massive memory allocation for the decompressed data.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "urllib3: urllib3 vulnerable to decompression-bomb safeguard bypass when following HTTP redirects (streaming API)",
    "cve": "CVE-2026-21441",
    "package": "python3-urllib3",
    "severity": "HIGH",
    "installed_version": "2.3.0-3",
    "fixed_version": "2.3.0-3+deb13u1",
    "description": "urllib3 is an HTTP client library for Python. urllib3's streaming API is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once. urllib3 can perform decoding or decompression based on the HTTP `Content-Encoding` header (e.g., `gzip`, `deflate`, `br`, or `zstd`). When using the streaming API, the library decompresses only the necessary bytes, enabling partial content consumption. Starting in version 1.22 and prior to version 2.6.3, for HTTP redirect responses, the library would read the entire response body to drain the connection and decompress the content unnecessarily. This decompression occurred even before any read methods were called, and configured read limits did not restrict the amount of decompressed data. As a result, there was no safeguard against decompression bombs. A malicious server could exploit this to trigger excessive resource consumption on the client. Applications and libraries are affected when they stream content from untrusted sources by setting `preload_content=False` when they do not disable redirects. Users should upgrade to at least urllib3 v2.6.3, in which the library does not decode content of redirect responses when `preload_content=False`. If upgrading is not immediately possible, disable redirects by setting `redirect=False` for requests to untrusted source.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "wheel: wheel: Privilege Escalation or Arbitrary Code Execution via malicious wheel file unpacking",
    "cve": "CVE-2026-24049",
    "package": "python3-wheel",
    "severity": "HIGH",
    "installed_version": "0.46.1-2",
    "fixed_version": null,
    "description": "wheel is a command line tool for manipulating Python wheel files, as defined in PEP 427. In versions 0.40.0 through 0.46.1, the unpack function is vulnerable to file permission modification through mishandling of file permissions after extraction. The logic blindly trusts the filename from the archive header for the chmod operation, even though the extraction process itself might have sanitized the path. Attackers can craft a malicious wheel file that, when unpacked, changes the permissions of critical system files (e.g., /etc/passwd, SSH keys, config files), allowing for Privilege Escalation or arbitrary code execution by modifying now-writable scripts. This issue has been fixed in version 0.46.2.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: IMAP command injection in user-controlled commands",
    "cve": "CVE-2025-15366",
    "package": "python3.13",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The imaplib module, when passed a user-controlled command, can have additional commands injected using newlines. Mitigation rejects commands containing control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: POP3 command injection in user-controlled commands",
    "cve": "CVE-2025-15367",
    "package": "python3.13",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The poplib module, when passed a user-controlled command, can have\nadditional commands injected using newlines. Mitigation rejects commands\ncontaining control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: Cpython infinite loop when parsing a tarfile",
    "cve": "CVE-2025-8194",
    "package": "python3.13",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "There is a defect in the CPython \u201ctarfile\u201d module affecting the \u201cTarFile\u201d extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives. \n\nThis vulnerability can be mitigated by including the following patch after importing the \u201ctarfile\u201d module:\u00a0 https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: email header injection due to unquoted newlines",
    "cve": "CVE-2026-1299",
    "package": "python3.13",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The \nemail module, specifically the \"BytesGenerator\" class, didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized. This is only applicable if using \"LiteralHeader\" writing headers that don't respect email folding rules, the new behavior will reject the incorrectly folded headers in \"BytesGenerator\".",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: IMAP command injection in user-controlled commands",
    "cve": "CVE-2025-15366",
    "package": "python3.13-dev",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The imaplib module, when passed a user-controlled command, can have additional commands injected using newlines. Mitigation rejects commands containing control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: POP3 command injection in user-controlled commands",
    "cve": "CVE-2025-15367",
    "package": "python3.13-dev",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The poplib module, when passed a user-controlled command, can have\nadditional commands injected using newlines. Mitigation rejects commands\ncontaining control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: Cpython infinite loop when parsing a tarfile",
    "cve": "CVE-2025-8194",
    "package": "python3.13-dev",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "There is a defect in the CPython \u201ctarfile\u201d module affecting the \u201cTarFile\u201d extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives. \n\nThis vulnerability can be mitigated by including the following patch after importing the \u201ctarfile\u201d module:\u00a0 https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: email header injection due to unquoted newlines",
    "cve": "CVE-2026-1299",
    "package": "python3.13-dev",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The \nemail module, specifically the \"BytesGenerator\" class, didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized. This is only applicable if using \"LiteralHeader\" writing headers that don't respect email folding rules, the new behavior will reject the incorrectly folded headers in \"BytesGenerator\".",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: IMAP command injection in user-controlled commands",
    "cve": "CVE-2025-15366",
    "package": "python3.13-minimal",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The imaplib module, when passed a user-controlled command, can have additional commands injected using newlines. Mitigation rejects commands containing control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: POP3 command injection in user-controlled commands",
    "cve": "CVE-2025-15367",
    "package": "python3.13-minimal",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The poplib module, when passed a user-controlled command, can have\nadditional commands injected using newlines. Mitigation rejects commands\ncontaining control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: Cpython infinite loop when parsing a tarfile",
    "cve": "CVE-2025-8194",
    "package": "python3.13-minimal",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "There is a defect in the CPython \u201ctarfile\u201d module affecting the \u201cTarFile\u201d extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives. \n\nThis vulnerability can be mitigated by including the following patch after importing the \u201ctarfile\u201d module:\u00a0 https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: email header injection due to unquoted newlines",
    "cve": "CVE-2026-1299",
    "package": "python3.13-minimal",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The \nemail module, specifically the \"BytesGenerator\" class, didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized. This is only applicable if using \"LiteralHeader\" writing headers that don't respect email folding rules, the new behavior will reject the incorrectly folded headers in \"BytesGenerator\".",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: IMAP command injection in user-controlled commands",
    "cve": "CVE-2025-15366",
    "package": "python3.13-venv",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The imaplib module, when passed a user-controlled command, can have additional commands injected using newlines. Mitigation rejects commands containing control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: POP3 command injection in user-controlled commands",
    "cve": "CVE-2025-15367",
    "package": "python3.13-venv",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The poplib module, when passed a user-controlled command, can have\nadditional commands injected using newlines. Mitigation rejects commands\ncontaining control characters.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: Cpython infinite loop when parsing a tarfile",
    "cve": "CVE-2025-8194",
    "package": "python3.13-venv",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "There is a defect in the CPython \u201ctarfile\u201d module affecting the \u201cTarFile\u201d extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives. \n\nThis vulnerability can be mitigated by including the following patch after importing the \u201ctarfile\u201d module:\u00a0 https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "cpython: email header injection due to unquoted newlines",
    "cve": "CVE-2026-1299",
    "package": "python3.13-venv",
    "severity": "HIGH",
    "installed_version": "3.13.5-2",
    "fixed_version": null,
    "description": "The \nemail module, specifically the \"BytesGenerator\" class, didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized. This is only applicable if using \"LiteralHeader\" writing headers that don't respect email folding rules, the new behavior will reject the incorrectly folded headers in \"BytesGenerator\".",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "QEMU: sdhci: buffer data port register off-by-one read/write",
    "cve": "CVE-2022-3872",
    "package": "qemu-utils",
    "severity": "HIGH",
    "installed_version": "1:10.0.3+ds-0+deb13u1",
    "fixed_version": null,
    "description": "An off-by-one read/write issue was found in the SDHCI device of QEMU. It occurs when reading/writing the Buffer Data Port Register in sdhci_read_dataport and sdhci_write_dataport, respectively, if data_count == block_size. A malicious guest could use this flaw to crash the QEMU process on the host, resulting in a denial of service condition.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "QEMU: 9pfs: SUID/SGID bits not dropped on file write",
    "cve": "CVE-2023-1386",
    "package": "qemu-utils",
    "severity": "HIGH",
    "installed_version": "1:10.0.3+ds-0+deb13u1",
    "fixed_version": null,
    "description": "A flaw was found in the 9p passthrough filesystem (9pfs) implementation in QEMU. When a local user in the guest writes an executable file with SUID or SGID, none of these privileged bits are correctly dropped. As a result, in rare circumstances, this flaw could be used by malicious users in the guest to elevate their privileges within the guest and help a host local user to elevate privileges on the host.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "qemu-kvm: lsi53c895a: use-after-free local privilege escalation vulnerability",
    "cve": "CVE-2024-6519",
    "package": "qemu-utils",
    "severity": "HIGH",
    "installed_version": "1:10.0.3+ds-0+deb13u1",
    "fixed_version": null,
    "description": "A use-after-free vulnerability was found in the QEMU LSI53C895A SCSI Host Bus Adapter emulation. This issue can lead to a crash or VM escape.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  },
  {
    "title": "qemu-kvm: VNC WebSocket handshake use-after-free",
    "cve": "CVE-2025-11234",
    "package": "qemu-utils",
    "severity": "HIGH",
    "installed_version": "1:10.0.3+ds-0+deb13u1",
    "fixed_version": "1:10.0.7+ds-0+deb13u1",
    "description": "A flaw was found in QEMU. If the QIOChannelWebsock object is freed while it is waiting to complete a handshake, a GSource is leaked. This can lead to the callback firing later on and triggering a use-after-free in the use of the channel. This can be abused by a malicious client with network access to the VNC WebSocket port to cause a denial of service during the WebSocket handshake prior to the VNC client authentication.",
    "dataSource": {
      "ID": "debian",
      "Name": "Debian Security Tracker",
      "URL": "https://salsa.debian.org/security-tracker-team/security-tracker"
    }
  }
]